{
  "address": "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "_symbol",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "_decimals",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oldVault",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newVault",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "effectiveTime",
          "type": "uint256"
        }
      ],
      "name": "LogChangeVault",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DOMAIN_SEPARATOR",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PERMIT_TYPEHASH",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "allowance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "balance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "burn",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "claimFees",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "encode64",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "hook",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "mint",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "nonces",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "v",
          "type": "uint8"
        },
        {
          "internalType": "bytes32",
          "name": "r",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "s",
          "type": "bytes32"
        }
      ],
      "name": "permit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "sqrt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "testWrongCall",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "testWrongCall2",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "testWrongCheckpoint",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "token",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "wad",
          "type": "uint256"
        }
      ],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xb2373f035d8ca97ee5339dcae1e4a0e0d70e2c1b355e26b2440afeb51ed323a1",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512",
    "transactionIndex": 0,
    "gasUsed": "1364361",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000",
    "blockHash": "0x71e95324660fc54162e97824f0f846be42fa0a686dd7f5ba0ab144dbce6f7b18",
    "transactionHash": "0xb2373f035d8ca97ee5339dcae1e4a0e0d70e2c1b355e26b2440afeb51ed323a1",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 2,
        "transactionHash": "0xb2373f035d8ca97ee5339dcae1e4a0e0d70e2c1b355e26b2440afeb51ed323a1",
        "address": "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000000000000000000000",
        "logIndex": 0,
        "blockHash": "0x71e95324660fc54162e97824f0f846be42fa0a686dd7f5ba0ab144dbce6f7b18"
      }
    ],
    "blockNumber": 2,
    "cumulativeGasUsed": "1364361",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "MTRG",
    "MTRG",
    18,
    "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
  ],
  "numDeployments": 2,
  "solcInputHash": "68fd470081266b8488fc3fbbafa06957",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldVault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newVault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"effectiveTime\",\"type\":\"uint256\"}],\"name\":\"LogChangeVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"encode64\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"hook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"sqrt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testWrongCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testWrongCall2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testWrongCheckpoint\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/test/Token.sol\":\"Token\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/base/Reentrancy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\nabstract contract Reentrancy {\\n    /// @dev simple re-entrancy check\\n    uint internal _unlocked = 1;\\n\\n    modifier lock() {\\n        require(_unlocked == 1, \\\"Reentrant call\\\");\\n        _unlocked = 2;\\n        _;\\n        _unlocked = 1;\\n    }\\n}\\n\",\"keccak256\":\"0x59c07b769bd280322dea57c93ed20b3e6e1fe1018ab9937b0dfcaddcfb5f2780\",\"license\":\"MIT\"},\"contracts/base/core/PairFees.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../interface/IERC20.sol\\\";\\nimport \\\"../../lib/SafeERC20.sol\\\";\\n\\n/// @title Base V1 Fees contract is used as a 1:1 pair relationship to split out fees,\\n///        this ensures that the curve does not need to be modified for LP shares\\ncontract PairFees {\\n    using SafeERC20 for IERC20;\\n\\n    /// @dev The pair it is bonded to\\n    address internal pair;\\n    /// @dev Token0 of pair, saved localy and statically for gas optimization\\n    address internal token0;\\n    /// @dev Token1 of pair, saved localy and statically for gas optimization\\n    address internal token1;\\n\\n    constructor(address _token0, address _token1) {\\n        pair = msg.sender;\\n        token0 = _token0;\\n        token1 = _token1;\\n    }\\n\\n    // Allow the pair to transfer fees to users\\n    function claimFeesFor(\\n        address recipient,\\n        uint amount0,\\n        uint amount1\\n    ) external {\\n        require(msg.sender == pair, \\\"Not pair\\\");\\n        if (amount0 > 0) {\\n            IERC20(token0).safeTransfer(recipient, amount0);\\n        }\\n        if (amount1 > 0) {\\n            IERC20(token1).safeTransfer(recipient, amount1);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xed2db5d1b51dcaf2662d6871c6a0ee7c7e3229c36c86728524c76755b6b1c628\",\"license\":\"MIT\"},\"contracts/base/core/VoltPair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../interface/IERC20.sol\\\";\\nimport \\\"../../interface/IERC721Metadata.sol\\\";\\nimport \\\"../../interface/IPair.sol\\\";\\nimport \\\"../../interface/IFactory.sol\\\";\\nimport \\\"../../interface/ICallee.sol\\\";\\nimport \\\"../../interface/IUnderlying.sol\\\";\\nimport \\\"./PairFees.sol\\\";\\nimport \\\"../../lib/Math.sol\\\";\\nimport \\\"../../lib/SafeERC20.sol\\\";\\nimport \\\"../Reentrancy.sol\\\";\\n\\n// The base pair of pools, either stable or volatile\\ncontract VoltPair is IERC20, IPair, Reentrancy {\\n    using SafeERC20 for IERC20;\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public constant decimals = 18;\\n\\n    /// @dev Used to denote stable or volatile pair\\n    bool public stable;\\n\\n    uint public override totalSupply = 0;\\n\\n    mapping(address => mapping(address => uint)) public override allowance;\\n    mapping(address => uint) public override balanceOf;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    uint internal constant _FEE_PRECISION = 1e32;\\n    mapping(address => uint) public nonces;\\n    uint public chainId;\\n\\n    uint internal constant MINIMUM_LIQUIDITY = 10**3;\\n    /// @dev 50% of swap fee\\n    uint internal constant TREASURY_FEE = 2;\\n    /// @dev Capture oracle reading every 30 minutes\\n    uint internal constant PERIOD_SIZE = 1800;\\n\\n    address public override token0;\\n    address public override token1;\\n    address public fees;\\n    address public factory;\\n\\n    Observation[] public observations;\\n\\n    uint internal decimals0;\\n    uint internal decimals1;\\n\\n    uint public reserve0;\\n    uint public reserve1;\\n    uint public blockTimestampLast;\\n\\n    uint public reserve0CumulativeLast;\\n    uint public reserve1CumulativeLast;\\n\\n    // index0 and index1 are used to accumulate fees,\\n    // this is split out from normal trades to keep the swap \\\"clean\\\"\\n    // this further allows LP holders to easily claim fees for tokens they have/staked\\n    uint public index0 = 0;\\n    uint public index1 = 0;\\n\\n    // position assigned to each LP to track their current index0 & index1 vs the global position\\n    mapping(address => uint) public supplyIndex0;\\n    mapping(address => uint) public supplyIndex1;\\n\\n    // tracks the amount of unclaimed, but claimable tokens off of fees for token0 and token1\\n    mapping(address => uint) public claimable0;\\n    mapping(address => uint) public claimable1;\\n\\n    event Treasury(address indexed sender, uint amount0, uint amount1);\\n    event Fees(address indexed sender, uint amount0, uint amount1);\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(\\n        address indexed sender,\\n        uint amount0,\\n        uint amount1,\\n        address indexed to\\n    );\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint reserve0, uint reserve1);\\n    event Claim(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint amount0,\\n        uint amount1\\n    );\\n\\n    constructor() {\\n        factory = msg.sender;\\n        (address _token0, address _token1, bool _stable) = IFactory(msg.sender)\\n            .getInitializable();\\n        (token0, token1, stable) = (_token0, _token1, _stable);\\n        fees = address(new PairFees(_token0, _token1));\\n        if (_stable) {\\n            name = string(\\n                abi.encodePacked(\\n                    \\\"StableV1 AMM - \\\",\\n                    IERC721Metadata(_token0).symbol(),\\n                    \\\"/\\\",\\n                    IERC721Metadata(_token1).symbol()\\n                )\\n            );\\n            symbol = string(\\n                abi.encodePacked(\\n                    \\\"sAMM-\\\",\\n                    IERC721Metadata(_token0).symbol(),\\n                    \\\"/\\\",\\n                    IERC721Metadata(_token1).symbol()\\n                )\\n            );\\n        } else {\\n            name = string(\\n                abi.encodePacked(\\n                    \\\"VolatileV1 AMM - \\\",\\n                    IERC721Metadata(_token0).symbol(),\\n                    \\\"/\\\",\\n                    IERC721Metadata(_token1).symbol()\\n                )\\n            );\\n            symbol = string(\\n                abi.encodePacked(\\n                    \\\"vAMM-\\\",\\n                    IERC721Metadata(_token0).symbol(),\\n                    \\\"/\\\",\\n                    IERC721Metadata(_token1).symbol()\\n                )\\n            );\\n        }\\n\\n        decimals0 = 10**IUnderlying(_token0).decimals();\\n        decimals1 = 10**IUnderlying(_token1).decimals();\\n\\n        observations.push(Observation(block.timestamp, 0, 0));\\n\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(name)),\\n                keccak256(\\\"1\\\"),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n        chainId = block.chainid;\\n    }\\n\\n    function observationLength() external view returns (uint) {\\n        return observations.length;\\n    }\\n\\n    function lastObservation() public view returns (Observation memory) {\\n        return observations[observations.length - 1];\\n    }\\n\\n    function metadata()\\n        external\\n        view\\n        returns (\\n            uint dec0,\\n            uint dec1,\\n            uint r0,\\n            uint r1,\\n            bool st,\\n            address t0,\\n            address t1\\n        )\\n    {\\n        return (\\n            decimals0,\\n            decimals1,\\n            reserve0,\\n            reserve1,\\n            stable,\\n            token0,\\n            token1\\n        );\\n    }\\n\\n    function tokens() external view override returns (address, address) {\\n        return (token0, token1);\\n    }\\n\\n    /// @dev Claim accumulated but unclaimed fees (viewable via claimable0 and claimable1)\\n    function claimFees()\\n        external\\n        override\\n        returns (uint claimed0, uint claimed1)\\n    {\\n        _updateFor(msg.sender);\\n\\n        claimed0 = claimable0[msg.sender];\\n        claimed1 = claimable1[msg.sender];\\n\\n        if (claimed0 > 0 || claimed1 > 0) {\\n            claimable0[msg.sender] = 0;\\n            claimable1[msg.sender] = 0;\\n\\n            PairFees(fees).claimFeesFor(msg.sender, claimed0, claimed1);\\n\\n            emit Claim(msg.sender, msg.sender, claimed0, claimed1);\\n        }\\n    }\\n\\n    /// @dev Accrue fees on token0\\n    function _update0(uint amount) internal {\\n        uint toTreasury;\\n        address treasury = IFactory(factory).treasury();\\n        if (treasury != address(0)) {\\n            toTreasury = amount / TREASURY_FEE;\\n            // transfer the fees out to PairFees and Treasury\\n            IERC20(token0).safeTransfer(treasury, toTreasury);\\n            // keep the same structure of events for compatability\\n            emit Treasury(msg.sender, toTreasury, 0);\\n        }\\n        uint toFees = amount - toTreasury;\\n        IERC20(token0).safeTransfer(fees, toFees);\\n        // 1e32 adjustment is removed during claim\\n        uint _ratio = (toFees * _FEE_PRECISION) / totalSupply;\\n        if (_ratio > 0) {\\n            index0 += _ratio;\\n        }\\n        emit Fees(msg.sender, toFees, 0);\\n    }\\n\\n    /// @dev Accrue fees on token1\\n    function _update1(uint amount) internal {\\n        uint toTreasury;\\n        address treasury = IFactory(factory).treasury();\\n        if (treasury != address(0)) {\\n            toTreasury = amount / TREASURY_FEE;\\n            // transfer the fees out to PairFees and Treasury\\n            IERC20(token1).safeTransfer(treasury, toTreasury);\\n            // keep the same structure of events for compatability\\n            emit Treasury(msg.sender, 0, toTreasury);\\n        }\\n        uint toFees = amount - toTreasury;\\n        IERC20(token1).safeTransfer(fees, toFees);\\n        uint _ratio = (toFees * _FEE_PRECISION) / totalSupply;\\n        if (_ratio > 0) {\\n            index1 += _ratio;\\n        }\\n        emit Fees(msg.sender, 0, toFees);\\n    }\\n\\n    /// @dev This function MUST be called on any balance changes,\\n    ///      otherwise can be used to infinitely claim fees\\n    //       Fees are segregated from core funds, so fees can never put liquidity at risk\\n    function _updateFor(address recipient) internal {\\n        uint _supplied = balanceOf[recipient];\\n        // get LP balance of `recipient`\\n        if (_supplied > 0) {\\n            uint _supplyIndex0 = supplyIndex0[recipient];\\n            // get last adjusted index0 for recipient\\n            uint _supplyIndex1 = supplyIndex1[recipient];\\n            uint _index0 = index0;\\n            // get global index0 for accumulated fees\\n            uint _index1 = index1;\\n            supplyIndex0[recipient] = _index0;\\n            // update user current position to global position\\n            supplyIndex1[recipient] = _index1;\\n            uint _delta0 = _index0 - _supplyIndex0;\\n            // see if there is any difference that need to be accrued\\n            uint _delta1 = _index1 - _supplyIndex1;\\n            if (_delta0 > 0) {\\n                uint _share = (_supplied * _delta0) / _FEE_PRECISION;\\n                // add accrued difference for each supplied token\\n                claimable0[recipient] += _share;\\n            }\\n            if (_delta1 > 0) {\\n                uint _share = (_supplied * _delta1) / _FEE_PRECISION;\\n                claimable1[recipient] += _share;\\n            }\\n        } else {\\n            supplyIndex0[recipient] = index0;\\n            // new users are set to the default global state\\n            supplyIndex1[recipient] = index1;\\n        }\\n    }\\n\\n    function getReserves()\\n        public\\n        view\\n        override\\n        returns (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n            uint32 _blockTimestampLast\\n        )\\n    {\\n        _reserve0 = uint112(reserve0);\\n        _reserve1 = uint112(reserve1);\\n        _blockTimestampLast = uint32(blockTimestampLast);\\n    }\\n\\n    /// @dev Update reserves and, on the first call per block, price accumulators\\n    function _update(\\n        uint balance0,\\n        uint balance1,\\n        uint _reserve0,\\n        uint _reserve1\\n    ) internal {\\n        uint blockTimestamp = block.timestamp;\\n        uint timeElapsed = blockTimestamp - blockTimestampLast;\\n        // overflow is desired\\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\\n            unchecked {\\n                reserve0CumulativeLast += _reserve0 * timeElapsed;\\n                reserve1CumulativeLast += _reserve1 * timeElapsed;\\n            }\\n        }\\n\\n        Observation memory _point = lastObservation();\\n        timeElapsed = blockTimestamp - _point.timestamp;\\n        // compare the last observation with current timestamp,\\n        // if greater than 30 minutes, record a new event\\n        if (timeElapsed > PERIOD_SIZE) {\\n            observations.push(\\n                Observation(\\n                    blockTimestamp,\\n                    reserve0CumulativeLast,\\n                    reserve1CumulativeLast\\n                )\\n            );\\n        }\\n        reserve0 = balance0;\\n        reserve1 = balance1;\\n        blockTimestampLast = blockTimestamp;\\n        emit Sync(reserve0, reserve1);\\n    }\\n\\n    /// @dev Produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices()\\n        public\\n        view\\n        returns (\\n            uint reserve0Cumulative,\\n            uint reserve1Cumulative,\\n            uint blockTimestamp\\n        )\\n    {\\n        blockTimestamp = block.timestamp;\\n        reserve0Cumulative = reserve0CumulativeLast;\\n        reserve1Cumulative = reserve1CumulativeLast;\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (\\n            uint _reserve0,\\n            uint _reserve1,\\n            uint _blockTimestampLast\\n        ) = getReserves();\\n        if (_blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint timeElapsed = blockTimestamp - _blockTimestampLast;\\n            unchecked {\\n                reserve0Cumulative += _reserve0 * timeElapsed;\\n                reserve1Cumulative += _reserve1 * timeElapsed;\\n            }\\n        }\\n    }\\n\\n    /// @dev Gives the current twap price measured from amountIn * tokenIn gives amountOut\\n    function current(address tokenIn, uint amountIn)\\n        external\\n        view\\n        returns (uint amountOut)\\n    {\\n        Observation memory _observation = lastObservation();\\n        (\\n            uint reserve0Cumulative,\\n            uint reserve1Cumulative,\\n\\n        ) = currentCumulativePrices();\\n        if (block.timestamp == _observation.timestamp) {\\n            _observation = observations[observations.length - 2];\\n        }\\n\\n        uint timeElapsed = block.timestamp - _observation.timestamp;\\n        uint _reserve0 = (reserve0Cumulative -\\n            _observation.reserve0Cumulative) / timeElapsed;\\n        uint _reserve1 = (reserve1Cumulative -\\n            _observation.reserve1Cumulative) / timeElapsed;\\n        amountOut = _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\\n    }\\n\\n    /// @dev As per `current`, however allows user configured granularity, up to the full window size\\n    function quote(\\n        address tokenIn,\\n        uint amountIn,\\n        uint granularity\\n    ) external view returns (uint amountOut) {\\n        uint[] memory _prices = sample(tokenIn, amountIn, granularity, 1);\\n        uint priceAverageCumulative;\\n        for (uint i = 0; i < _prices.length; i++) {\\n            priceAverageCumulative += _prices[i];\\n        }\\n        return priceAverageCumulative / granularity;\\n    }\\n\\n    /// @dev Returns a memory set of twap prices\\n    function prices(\\n        address tokenIn,\\n        uint amountIn,\\n        uint points\\n    ) external view returns (uint[] memory) {\\n        return sample(tokenIn, amountIn, points, 1);\\n    }\\n\\n    function sample(\\n        address tokenIn,\\n        uint amountIn,\\n        uint points,\\n        uint window\\n    ) public view returns (uint[] memory) {\\n        uint[] memory _prices = new uint[](points);\\n\\n        uint length = observations.length - 1;\\n        uint i = length - (points * window);\\n        uint nextIndex = 0;\\n        uint index = 0;\\n\\n        for (; i < length; i += window) {\\n            nextIndex = i + window;\\n            uint timeElapsed = observations[nextIndex].timestamp -\\n                observations[i].timestamp;\\n            uint _reserve0 = (observations[nextIndex].reserve0Cumulative -\\n                observations[i].reserve0Cumulative) / timeElapsed;\\n            uint _reserve1 = (observations[nextIndex].reserve1Cumulative -\\n                observations[i].reserve1Cumulative) / timeElapsed;\\n            _prices[index] = _getAmountOut(\\n                amountIn,\\n                tokenIn,\\n                _reserve0,\\n                _reserve1\\n            );\\n            index = index + 1;\\n        }\\n        return _prices;\\n    }\\n\\n    /// @dev This low-level function should be called from a contract which performs important safety checks\\n    ///      standard uniswap v2 implementation\\n    function mint(address to) external override lock returns (uint liquidity) {\\n        (uint _reserve0, uint _reserve1) = (reserve0, reserve1);\\n        uint _balance0 = IERC20(token0).balanceOf(address(this));\\n        uint _balance1 = IERC20(token1).balanceOf(address(this));\\n        uint _amount0 = _balance0 - _reserve0;\\n        uint _amount1 = _balance1 - _reserve1;\\n\\n        uint _totalSupply = totalSupply;\\n        // gas savings, must be defined here since totalSupply can update in _mintFee\\n        if (_totalSupply == 0) {\\n            liquidity = Math.sqrt(_amount0 * _amount1) - MINIMUM_LIQUIDITY;\\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\\n            _mint(address(0), MINIMUM_LIQUIDITY);\\n        } else {\\n            liquidity = Math.min(\\n                (_amount0 * _totalSupply) / _reserve0,\\n                (_amount1 * _totalSupply) / _reserve1\\n            );\\n        }\\n        require(liquidity > 0, \\\"VoltPair: INSUFFICIENT_LIQUIDITY_MINTED\\\");\\n        _mint(to, liquidity);\\n\\n        _update(_balance0, _balance1, _reserve0, _reserve1);\\n        emit Mint(msg.sender, _amount0, _amount1);\\n    }\\n\\n    /// @dev This low-level function should be called from a contract which performs important safety checks\\n    ///      standard uniswap v2 implementation\\n    function burn(address to)\\n        external\\n        override\\n        lock\\n        returns (uint amount0, uint amount1)\\n    {\\n        (uint _reserve0, uint _reserve1) = (reserve0, reserve1);\\n        (address _token0, address _token1) = (token0, token1);\\n        uint _balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint _balance1 = IERC20(_token1).balanceOf(address(this));\\n        uint _liquidity = balanceOf[address(this)];\\n\\n        // gas savings, must be defined here since totalSupply can update in _mintFee\\n        uint _totalSupply = totalSupply;\\n        // using balances ensures pro-rata distribution\\n        amount0 = (_liquidity * _balance0) / _totalSupply;\\n        // using balances ensures pro-rata distribution\\n        amount1 = (_liquidity * _balance1) / _totalSupply;\\n        require(\\n            amount0 > 0 && amount1 > 0,\\n            \\\"VoltPair: INSUFFICIENT_LIQUIDITY_BURNED\\\"\\n        );\\n        _burn(address(this), _liquidity);\\n        IERC20(_token0).safeTransfer(to, amount0);\\n        IERC20(_token1).safeTransfer(to, amount1);\\n        _balance0 = IERC20(_token0).balanceOf(address(this));\\n        _balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n        _update(_balance0, _balance1, _reserve0, _reserve1);\\n        emit Burn(msg.sender, amount0, amount1, to);\\n    }\\n\\n    /// @dev This low-level function should be called from a contract which performs important safety checks\\n    function swap(\\n        uint amount0Out,\\n        uint amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external override lock {\\n        require(!IFactory(factory).isPaused(), \\\"VoltPair: PAUSE\\\");\\n        require(\\n            amount0Out > 0 || amount1Out > 0,\\n            \\\"VoltPair: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n        (uint _reserve0, uint _reserve1) = (reserve0, reserve1);\\n        require(\\n            amount0Out < _reserve0 && amount1Out < _reserve1,\\n            \\\"VoltPair: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        uint _balance0;\\n        uint _balance1;\\n        {\\n            // scope for _token{0,1}, avoids stack too deep errors\\n            (address _token0, address _token1) = (token0, token1);\\n            require(to != _token0 && to != _token1, \\\"VoltPair: INVALID_TO\\\");\\n            // optimistically transfer tokens\\n            if (amount0Out > 0) IERC20(_token0).safeTransfer(to, amount0Out);\\n            // optimistically transfer tokens\\n            if (amount1Out > 0) IERC20(_token1).safeTransfer(to, amount1Out);\\n            // callback, used for flash loans\\n            if (data.length > 0)\\n                ICallee(to).hook(msg.sender, amount0Out, amount1Out, data);\\n            _balance0 = IERC20(_token0).balanceOf(address(this));\\n            _balance1 = IERC20(_token1).balanceOf(address(this));\\n        }\\n        uint amount0In = _balance0 > _reserve0 - amount0Out\\n            ? _balance0 - (_reserve0 - amount0Out)\\n            : 0;\\n        uint amount1In = _balance1 > _reserve1 - amount1Out\\n            ? _balance1 - (_reserve1 - amount1Out)\\n            : 0;\\n        require(\\n            amount0In > 0 || amount1In > 0,\\n            \\\"VoltPair: INSUFFICIENT_INPUT_AMOUNT\\\"\\n        );\\n        {\\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\\n            (address _token0, address _token1) = (token0, token1);\\n            // accrue fees for token0 and move them out of pool\\n            if (amount0In > 0) _update0(swapFee(amount0In));\\n            // accrue fees for token1 and move them out of pool\\n            if (amount1In > 0) _update1(swapFee(amount1In));\\n            // since we removed tokens, we need to reconfirm balances,\\n            // can also simply use previous balance - amountIn/ SWAP_FEE,\\n            // but doing balanceOf again as safety check\\n            _balance0 = IERC20(_token0).balanceOf(address(this));\\n            _balance1 = IERC20(_token1).balanceOf(address(this));\\n            // The curve, either x3y+y3x for stable pools, or x*y for volatile pools\\n            require(\\n                _k(_balance0, _balance1) >= _k(_reserve0, _reserve1),\\n                \\\"VoltPair: K\\\"\\n            );\\n        }\\n\\n        _update(_balance0, _balance1, _reserve0, _reserve1);\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    /// @dev Force balances to match reserves\\n    function skim(address to) external lock {\\n        (address _token0, address _token1) = (token0, token1);\\n        IERC20(_token0).safeTransfer(\\n            to,\\n            IERC20(_token0).balanceOf(address(this)) - (reserve0)\\n        );\\n        IERC20(_token1).safeTransfer(\\n            to,\\n            IERC20(_token1).balanceOf(address(this)) - (reserve1)\\n        );\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external lock {\\n        _update(\\n            IERC20(token0).balanceOf(address(this)),\\n            IERC20(token1).balanceOf(address(this)),\\n            reserve0,\\n            reserve1\\n        );\\n    }\\n\\n    function _f(uint x0, uint y) internal pure returns (uint) {\\n        return\\n            (x0 * ((((y * y) / 1e18) * y) / 1e18)) /\\n            1e18 +\\n            (((((x0 * x0) / 1e18) * x0) / 1e18) * y) /\\n            1e18;\\n    }\\n\\n    function _d(uint x0, uint y) internal pure returns (uint) {\\n        return\\n            (3 * x0 * ((y * y) / 1e18)) /\\n            1e18 +\\n            ((((x0 * x0) / 1e18) * x0) / 1e18);\\n    }\\n\\n    function _getY(\\n        uint x0,\\n        uint xy,\\n        uint y\\n    ) internal pure returns (uint) {\\n        for (uint i = 0; i < 255; i++) {\\n            uint yPrev = y;\\n            uint k = _f(x0, y);\\n            if (k < xy) {\\n                uint dy = ((xy - k) * 1e18) / _d(x0, y);\\n                y = y + dy;\\n            } else {\\n                uint dy = ((k - xy) * 1e18) / _d(x0, y);\\n                y = y - dy;\\n            }\\n            if (Math.closeTo(y, yPrev, 1)) {\\n                break;\\n            }\\n        }\\n        return y;\\n    }\\n\\n    function getAmountOut(uint amountIn, address tokenIn)\\n        external\\n        view\\n        override\\n        returns (uint)\\n    {\\n        (uint _reserve0, uint _reserve1) = (reserve0, reserve1);\\n        // remove fee from amount received\\n        amountIn -= swapFee(amountIn);\\n        return _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\\n    }\\n\\n    function _getAmountOut(\\n        uint amountIn,\\n        address tokenIn,\\n        uint _reserve0,\\n        uint _reserve1\\n    ) internal view returns (uint) {\\n        if (stable) {\\n            uint xy = _k(_reserve0, _reserve1);\\n            _reserve0 = (_reserve0 * 1e18) / decimals0;\\n            _reserve1 = (_reserve1 * 1e18) / decimals1;\\n            (uint reserveA, uint reserveB) = tokenIn == token0\\n                ? (_reserve0, _reserve1)\\n                : (_reserve1, _reserve0);\\n            amountIn = tokenIn == token0\\n                ? (amountIn * 1e18) / decimals0\\n                : (amountIn * 1e18) / decimals1;\\n            uint y = reserveB - _getY(amountIn + reserveA, xy, reserveB);\\n            return (y * (tokenIn == token0 ? decimals1 : decimals0)) / 1e18;\\n        } else {\\n            (uint reserveA, uint reserveB) = tokenIn == token0\\n                ? (_reserve0, _reserve1)\\n                : (_reserve1, _reserve0);\\n            return (amountIn * reserveB) / (reserveA + amountIn);\\n        }\\n    }\\n\\n    function _k(uint x, uint y) internal view returns (uint) {\\n        if (stable) {\\n            uint _x = (x * 1e18) / decimals0;\\n            uint _y = (y * 1e18) / decimals1;\\n            uint _a = (_x * _y) / 1e18;\\n            uint _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\\n            // x3y+y3x >= k\\n            return (_a * _b) / 1e18;\\n        } else {\\n            // xy >= k\\n            return x * y;\\n        }\\n    }\\n\\n    function swapFee(uint256 amount) internal view returns (uint256) {\\n        if (stable) {\\n            return (amount * 4) / 10000;\\n        } else {\\n            return (amount * 3) / 1000;\\n        }\\n    }\\n\\n    //****************************************************************************\\n    //**************************** ERC20 *****************************************\\n    //****************************************************************************\\n\\n    function _mint(address dst, uint amount) internal {\\n        // balances must be updated on mint/burn/transfer\\n        _updateFor(dst);\\n        totalSupply += amount;\\n        balanceOf[dst] += amount;\\n        emit Transfer(address(0), dst, amount);\\n    }\\n\\n    function _burn(address dst, uint amount) internal {\\n        _updateFor(dst);\\n        totalSupply -= amount;\\n        balanceOf[dst] -= amount;\\n        emit Transfer(dst, address(0), amount);\\n    }\\n\\n    function approve(address spender, uint amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        require(spender != address(0), \\\"VoltPair: Approve to the zero address\\\");\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint value,\\n        uint deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        require(deadline >= block.timestamp, \\\"VoltPair: EXPIRED\\\");\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        owner,\\n                        spender,\\n                        value,\\n                        nonces[owner]++,\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(\\n            recoveredAddress != address(0) && recoveredAddress == owner,\\n            \\\"VoltPair: INVALID_SIGNATURE\\\"\\n        );\\n        allowance[owner][spender] = value;\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function transfer(address dst, uint amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _transferTokens(msg.sender, dst, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint amount\\n    ) external override returns (bool) {\\n        address spender = msg.sender;\\n        uint spenderAllowance = allowance[src][spender];\\n\\n        if (spender != src && spenderAllowance != type(uint).max) {\\n            require(\\n                spenderAllowance >= amount,\\n                \\\"VoltPair: Insufficient allowance\\\"\\n            );\\n            unchecked {\\n                uint newAllowance = spenderAllowance - amount;\\n                allowance[src][spender] = newAllowance;\\n                emit Approval(src, spender, newAllowance);\\n            }\\n        }\\n\\n        _transferTokens(src, dst, amount);\\n        return true;\\n    }\\n\\n    function _transferTokens(\\n        address src,\\n        address dst,\\n        uint amount\\n    ) internal {\\n        require(dst != address(0), \\\"VoltPair: Transfer to the zero address\\\");\\n\\n        // update fee position for src\\n        _updateFor(src);\\n        // update fee position for dst\\n        _updateFor(dst);\\n\\n        uint srcBalance = balanceOf[src];\\n        require(\\n            srcBalance >= amount,\\n            \\\"VoltPair: Transfer amount exceeds balance\\\"\\n        );\\n        unchecked {\\n            balanceOf[src] = srcBalance - amount;\\n        }\\n\\n        balanceOf[dst] += amount;\\n\\n        emit Transfer(src, dst, amount);\\n    }\\n}\\n\",\"keccak256\":\"0x1727b7e30f7c4a60a143605313a89b9a5e01b0345165310b26e3cf52f9537a42\",\"license\":\"MIT\"},\"contracts/interface/ICallee.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\ninterface ICallee {\\n    function hook(\\n        address sender,\\n        uint amount0,\\n        uint amount1,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x2fab4d26f3f7c642d1bfbf989352d2fac71442d135cb64341f560c53ad1ec5b1\",\"license\":\"MIT\"},\"contracts/interface/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x8609505e815e06dac85e0cc77ad7bbb641ceec24e5c8e012483e8576dd09ce09\",\"license\":\"MIT\"},\"contracts/interface/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\",\"keccak256\":\"0x224e032b714ae191e5e419054a144402b01597e8b2eb36db4f6e38d3e42b0db7\",\"license\":\"MIT\"},\"contracts/interface/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x6983264dae1151fd2451f1cb2e4cb9a369f6dd25577600d1733fe6e4da0dc35d\",\"license\":\"MIT\"},\"contracts/interface/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x25b30686d5b7b33b8c7e58a5cef5f01d04f2405a92623f923a7bc36c6271733c\",\"license\":\"MIT\"},\"contracts/interface/IFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\ninterface IFactory {\\n    function treasury() external view returns (address);\\n\\n    function isPair(address pair) external view returns (bool);\\n\\n    function getInitializable()\\n        external\\n        view\\n        returns (\\n            address,\\n            address,\\n            bool\\n        );\\n\\n    function isPaused() external view returns (bool);\\n\\n    function pairCodeHash() external pure returns (bytes32);\\n\\n    function getPair(\\n        address tokenA,\\n        address token,\\n        bool stable\\n    ) external view returns (address);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB,\\n        bool stable\\n    ) external returns (address pair);\\n}\\n\",\"keccak256\":\"0x22270dbb92d05a3dae6d38084db2ce1db27dee00af111b6502c34efe7106508b\",\"license\":\"MIT\"},\"contracts/interface/IPair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\ninterface IPair {\\n    // Structure to capture time period obervations every 30 minutes, used for local oracles\\n    struct Observation {\\n        uint timestamp;\\n        uint reserve0Cumulative;\\n        uint reserve1Cumulative;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint value,\\n        uint deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function swap(\\n        uint amount0Out,\\n        uint amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n\\n    function mint(address to) external returns (uint liquidity);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n            uint32 _blockTimestampLast\\n        );\\n\\n    function getAmountOut(uint, address) external view returns (uint);\\n\\n    function claimFees() external returns (uint, uint);\\n\\n    function tokens() external view returns (address, address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function stable() external view returns (bool);\\n\\n    function metadata()\\n        external\\n        view\\n        returns (\\n            uint dec0,\\n            uint dec1,\\n            uint r0,\\n            uint r1,\\n            bool st,\\n            address t0,\\n            address t1\\n        );\\n}\\n\",\"keccak256\":\"0x978d3132f8f5f6752533d94a3024f25ced205df57475d5e2d7c09f301dd7c762\",\"license\":\"MIT\"},\"contracts/interface/IUnderlying.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\ninterface IUnderlying {\\n    function approve(address spender, uint value) external returns (bool);\\n\\n    function mint(address, uint) external;\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    function transfer(address, uint) external returns (bool);\\n\\n    function decimals() external returns (uint8);\\n}\\n\",\"keccak256\":\"0x9f1b01666233804a5e847f5385ec03364af51b2281eab803c8b4e1895e3c22ca\",\"license\":\"MIT\"},\"contracts/lib/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.13;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.call(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionDelegateCall(\\n                target,\\n                data,\\n                \\\"Address: low-level delegate call failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x284fcdaef2f20ec54759bfb0821ee3a3459a1f0bc302b29e7fcc3c2f42e728df\",\"license\":\"MIT\"},\"contracts/lib/Base64.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n    bytes internal constant TABLE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)\\n                )\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)\\n                )\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)\\n                )\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\",\"keccak256\":\"0xb3434ea5cfd5750fcad3e10ecbffbd9d4dbeac80b43cbb5a25cfb060ced37630\",\"license\":\"MIT\"},\"contracts/lib/CheckpointLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\nlibrary CheckpointLib {\\n    /// @notice A checkpoint for uint value\\n    struct Checkpoint {\\n        uint timestamp;\\n        uint value;\\n    }\\n\\n    function findLowerIndex(\\n        mapping(uint => Checkpoint) storage checkpoints,\\n        uint size,\\n        uint timestamp\\n    ) internal view returns (uint) {\\n        require(size != 0, \\\"Empty checkpoints\\\");\\n\\n        // First check most recent value\\n        if (checkpoints[size - 1].timestamp <= timestamp) {\\n            return (size - 1);\\n        }\\n\\n        // Next check implicit zero value\\n        if (checkpoints[0].timestamp > timestamp) {\\n            return 0;\\n        }\\n\\n        uint lower = 0;\\n        uint upper = size - 1;\\n        while (upper > lower) {\\n            // ceil, avoiding overflow\\n            uint center = upper - (upper - lower) / 2;\\n            Checkpoint memory cp = checkpoints[center];\\n            if (cp.timestamp == timestamp) {\\n                return center;\\n            } else if (cp.timestamp < timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n}\\n\",\"keccak256\":\"0xb5ccd2ad5421f03ed9b67825a8e4c89f6b67eb006352fda4bc444fc1f776bfcd\",\"license\":\"MIT\"},\"contracts/lib/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\nlibrary Math {\\n    function max(uint a, uint b) internal pure returns (uint) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function min(uint a, uint b) internal pure returns (uint) {\\n        return a < b ? a : b;\\n    }\\n\\n    function positiveInt128(int128 value) internal pure returns (int128) {\\n        return value < 0 ? int128(0) : value;\\n    }\\n\\n    function closeTo(\\n        uint a,\\n        uint b,\\n        uint target\\n    ) internal pure returns (bool) {\\n        if (a > b) {\\n            if (a - b <= target) {\\n                return true;\\n            }\\n        } else {\\n            if (b - a <= target) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8a50db5ef01ef869b1a7df3cf485d6c87473549c70fbefc54bdea34f8bc78538\",\"license\":\"MIT\"},\"contracts/lib/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.13;\\n\\nimport \\\"../interface/IERC20.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint value\\n    ) internal {\\n        uint newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(\\n            data,\\n            \\\"SafeERC20: low-level call failed\\\"\\n        );\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n            );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd09403b2f52a045a82861c53059fb835daabe908fd774f948370979588b3fe1a\",\"license\":\"MIT\"},\"contracts/test/Token.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\nimport \\\"../lib/Address.sol\\\";\\nimport \\\"../lib/Base64.sol\\\";\\nimport \\\"../lib/CheckpointLib.sol\\\";\\nimport \\\"../lib/Math.sol\\\";\\nimport \\\"../base/core/VoltPair.sol\\\";\\n\\ncontract Token {\\n    using Address for address;\\n    using CheckpointLib for mapping(uint => CheckpointLib.Checkpoint);\\n\\n    string public symbol;\\n    string public name;\\n    uint256 public decimals;\\n    uint256 public totalSupply = 0;\\n\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n    mapping(uint => CheckpointLib.Checkpoint) private _checkpoints;\\n\\n    event Transfer(address from, address to, uint256 value);\\n    event Approval(address owner, address spender, uint256 value);\\n    event LogChangeVault(\\n        address indexed oldVault,\\n        address indexed newVault,\\n        uint indexed effectiveTime\\n    );\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint) public nonces;\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint256 _decimals,\\n        address\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n        uint chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        {\\n            DOMAIN_SEPARATOR = keccak256(\\n                abi.encode(\\n                    keccak256(\\n                        \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                    ),\\n                    keccak256(bytes(name)),\\n                    keccak256(bytes(\\\"1\\\")),\\n                    chainId,\\n                    address(this)\\n                )\\n            );\\n            _mint(msg.sender, 0);\\n        }\\n    }\\n\\n    function approve(address _spender, uint256 _value) public returns (bool) {\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint value,\\n        uint deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(deadline >= block.timestamp, \\\"StableV1: EXPIRED\\\");\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        owner,\\n                        spender,\\n                        value,\\n                        nonces[owner]++,\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(\\n            recoveredAddress != address(0) && recoveredAddress == owner,\\n            \\\"StableV1: INVALID_SIGNATURE\\\"\\n        );\\n        allowance[owner][spender] = value;\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function token() external view returns (address) {\\n        return address(this);\\n    }\\n\\n    function balance(address account) external view returns (uint) {\\n        return balanceOf[account];\\n    }\\n\\n    function claimFees() external pure returns (uint, uint) {\\n        return (0, 0);\\n    }\\n\\n    function _mint(address _to, uint _amount) internal returns (bool) {\\n        balanceOf[_to] += _amount;\\n        totalSupply += _amount;\\n        emit Transfer(address(0x0), _to, _amount);\\n        return true;\\n    }\\n\\n    function _transfer(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) internal returns (bool) {\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    function transfer(address _to, uint256 _value) public returns (bool) {\\n        return _transfer(msg.sender, _to, _value);\\n    }\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) public returns (bool) {\\n        uint256 allowed_from = allowance[_from][msg.sender];\\n        require(allowance[_from][msg.sender] >= _value, \\\"Not enough allowance\\\");\\n        if (allowed_from != type(uint).max) {\\n            allowance[_from][msg.sender] -= _value;\\n        }\\n        return _transfer(_from, _to, _value);\\n    }\\n\\n    function mint(address account, uint256 amount) external returns (bool) {\\n        _mint(account, amount);\\n        return true;\\n    }\\n\\n    function burn(address account, uint256 amount) public returns (bool) {\\n        totalSupply -= amount;\\n        balanceOf[account] -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n        return true;\\n    }\\n\\n    function testWrongCall() external {\\n        (address(0)).functionCall(\\\"\\\", \\\"\\\");\\n    }\\n\\n    function testWrongCall2() external {\\n        address(this).functionCall(\\n            abi.encodeWithSelector(\\n                Token(this).transfer.selector,\\n                address(this),\\n                type(uint).max\\n            ),\\n            \\\"wrong\\\"\\n        );\\n    }\\n\\n    function encode64(bytes memory data) external pure returns (string memory) {\\n        return Base64.encode(data);\\n    }\\n\\n    function sqrt(uint value) external pure returns (uint) {\\n        return Math.sqrt(value);\\n    }\\n\\n    function testWrongCheckpoint() external view {\\n        _checkpoints.findLowerIndex(0, 0);\\n    }\\n\\n    function hook(\\n        address,\\n        uint,\\n        uint,\\n        bytes calldata data\\n    ) external {\\n        address pair = abi.decode(data, (address));\\n        VoltPair(pair).swap(0, 0, address(this), \\\"\\\");\\n    }\\n\\n    // --------------------- WMTR\\n\\n    function deposit() public payable {\\n        balanceOf[msg.sender] += msg.value;\\n    }\\n\\n    function withdraw(uint wad) public {\\n        require(balanceOf[msg.sender] >= wad);\\n        balanceOf[msg.sender] -= wad;\\n        payable(msg.sender).transfer(wad);\\n    }\\n}\\n\",\"keccak256\":\"0xdf395543f89a1f1d0cc6494e36c96d86d46094d5fc06086d2aced5d66b8e6fc0\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405260006003553480156200001657600080fd5b5060405162001a8b38038062001a8b833981016040819052620000399162000348565b83516200004e906001906020870190620001d5565b50825162000064906000906020860190620001d5565b50600282905560405146907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f906200009f9060019062000419565b60408051918290038220828201825260018352603160f81b6020938401528151928301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc66060820152608081018290523060a082015260c00160408051601f1981840301815291905280516020909101206007556200012a33600062000136565b505050505050620004e3565b6001600160a01b03821660009081526004602052604081208054839190839062000162908490620004bc565b9250508190555081600360008282546200017d9190620004bc565b909155505060408051600081526001600160a01b03851660208201529081018390527fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9060600160405180910390a150600192915050565b828054620001e390620003dd565b90600052602060002090601f01602090048101928262000207576000855562000252565b82601f106200022257805160ff191683800117855562000252565b8280016001018555821562000252579182015b828111156200025257825182559160200191906001019062000235565b506200026092915062000264565b5090565b5b8082111562000260576000815560010162000265565b634e487b7160e01b600052604160045260246000fd5b600082601f830112620002a357600080fd5b81516001600160401b0380821115620002c057620002c06200027b565b604051601f8301601f19908116603f01168101908282118183101715620002eb57620002eb6200027b565b816040528381526020925086838588010111156200030857600080fd5b600091505b838210156200032c57858201830151818301840152908201906200030d565b838211156200033e5760008385830101525b9695505050505050565b600080600080608085870312156200035f57600080fd5b84516001600160401b03808211156200037757600080fd5b620003858883890162000291565b955060208701519150808211156200039c57600080fd5b50620003ab8782880162000291565b60408701516060880151919550935090506001600160a01b0381168114620003d257600080fd5b939692955090935050565b600181811c90821680620003f257607f821691505b6020821081036200041357634e487b7160e01b600052602260045260246000fd5b50919050565b600080835481600182811c9150808316806200043657607f831692505b602080841082036200045657634e487b7160e01b86526022600452602486fd5b8180156200046d57600181146200047f57620004ae565b60ff19861689528489019650620004ae565b60008a81526020902060005b86811015620004a65781548b8201529085019083016200048b565b505084890196505b509498975050505050505050565b60008219821115620004de57634e487b7160e01b600052601160045260246000fd5b500190565b61159880620004f36000396000f3fe6080604052600436106101815760003560e01c80637ecebe00116100d1578063a9059cbb1161008a578063d505accf11610064578063d505accf1461043e578063dd62ed3e1461045e578063e3d670d714610496578063fc0c546a146104cc57600080fd5b8063a9059cbb146103f5578063d0e30db014610415578063d294f0931461041d57600080fd5b80637ecebe00146103495780638f5c286a1461037657806392e4dbea1461038b57806395d89b41146103a05780639a7bff79146103b55780639dc29fac146103d557600080fd5b8063313ce5671161013e5780634830155a116101185780634830155a146102c7578063677342ce146102e757806370a08231146103075780637bbdd3771461033457600080fd5b8063313ce5671461027b5780633644e5151461029157806340c10f19146102a757600080fd5b806306fdde0314610186578063095ea7b3146101b157806318160ddd146101e157806323b872dd146102055780632e1a7d4d1461022557806330adf81f14610247575b600080fd5b34801561019257600080fd5b5061019b6104e7565b6040516101a89190611117565b60405180910390f35b3480156101bd57600080fd5b506101d16101cc36600461115f565b610575565b60405190151581526020016101a8565b3480156101ed57600080fd5b506101f760035481565b6040519081526020016101a8565b34801561021157600080fd5b506101d161022036600461118b565b6105e0565b34801561023157600080fd5b506102456102403660046111cc565b6106a8565b005b34801561025357600080fd5b506101f77f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c981565b34801561028757600080fd5b506101f760025481565b34801561029d57600080fd5b506101f760075481565b3480156102b357600080fd5b506101d16102c236600461115f565b610719565b3480156102d357600080fd5b5061019b6102e23660046111fb565b61072f565b3480156102f357600080fd5b506101f76103023660046111cc565b610740565b34801561031357600080fd5b506101f76103223660046112ac565b60046020526000908152604090205481565b34801561034057600080fd5b5061024561074b565b34801561035557600080fd5b506101f76103643660046112ac565b60086020526000908152604090205481565b34801561038257600080fd5b5061024561075b565b34801561039757600080fd5b506102456107c4565b3480156103ac57600080fd5b5061019b6107ea565b3480156103c157600080fd5b506102456103d03660046112c9565b6107f7565b3480156103e157600080fd5b506101d16103f036600461115f565b610885565b34801561040157600080fd5b506101d161041036600461115f565b610900565b61024561090d565b34801561042957600080fd5b506040805160008082526020820152016101a8565b34801561044a57600080fd5b5061024561045936600461135f565b610933565b34801561046a57600080fd5b506101f76104793660046113d6565b600560209081526000928352604080842090915290825290205481565b3480156104a257600080fd5b506101f76104b13660046112ac565b6001600160a01b031660009081526004602052604090205490565b3480156104d857600080fd5b506040513081526020016101a8565b600180546104f49061140f565b80601f01602080910402602001604051908101604052809291908181526020018280546105209061140f565b801561056d5780601f106105425761010080835404028352916020019161056d565b820191906000526020600020905b81548152906001019060200180831161055057829003601f168201915b505050505081565b3360008181526005602090815260408083206001600160a01b03871684529091528082208490555190917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925916105cf919086908690611443565b60405180910390a150600192915050565b6001600160a01b0383166000908152600560209081526040808320338452909152812054828110156106505760405162461bcd60e51b81526020600482015260146024820152734e6f7420656e6f75676820616c6c6f77616e636560601b60448201526064015b60405180910390fd5b6000198114610692576001600160a01b03851660009081526005602090815260408083203384529091528120805485929061068c90849061147d565b90915550505b61069d858585610b9f565b9150505b9392505050565b336000908152600460205260409020548111156106c457600080fd5b33600090815260046020526040812080548392906106e390849061147d565b9091555050604051339082156108fc029083906000818181858888f19350505050158015610715573d6000803e3d6000fd5b5050565b60006107258383610c41565b5060019392505050565b606061073a82610cbe565b92915050565b600061073a82610e28565b6107586006600080610e98565b50565b6040805130602482018190526000196044808401919091528351808403909101815260649092018352602080830180516001600160e01b031663a9059cbb60e01b1790528351808501909452600584526477726f6e6760d81b9084015261075892909190610fde565b604080516020808201835260008083528351918201909352828152610758929190610fde565b600080546104f49061140f565b6000610805828401846112ac565b60405163022c0d9f60e01b8152600060048201819052602482018190523060448301526080606483015260848201529091506001600160a01b0382169063022c0d9f9060a401600060405180830381600087803b15801561086557600080fd5b505af1158015610879573d6000803e3d6000fd5b50505050505050505050565b60008160036000828254610899919061147d565b90915550506001600160a01b038316600090815260046020526040812080548492906108c690849061147d565b90915550506040517fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef906105cf9085906000908690611443565b60006106a1338484610b9f565b336000908152600460205260408120805434929061092c908490611494565b9091555050565b428410156109775760405162461bcd60e51b815260206004820152601160248201527014dd18589b19558c4e8811561412549151607a1b6044820152606401610647565b6007546001600160a01b038816600090815260086020526040812080549192917f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9918b918b918b9190876109ca836114ac565b909155506040805160208101969096526001600160a01b0394851690860152929091166060840152608083015260a082015260c0810187905260e00160405160208183030381529060405280519060200120604051602001610a4392919061190160f01b81526002810192909252602282015260420190565b60408051601f198184030181528282528051602091820120600080855291840180845281905260ff88169284019290925260608301869052608083018590529092509060019060a0016020604051602081039080840390855afa158015610aae573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b03811615801590610ae45750886001600160a01b0316816001600160a01b0316145b610b305760405162461bcd60e51b815260206004820152601b60248201527f537461626c6556313a20494e56414c49445f5349474e415455524500000000006044820152606401610647565b6001600160a01b03808a166000908152600560209081526040808320938c168352929052819020889055517f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92590610b8c908b908b908b90611443565b60405180910390a1505050505050505050565b6001600160a01b038316600090815260046020526040812080548391908390610bc990849061147d565b90915550506001600160a01b03831660009081526004602052604081208054849290610bf6908490611494565b90915550506040517fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef90610c2f90869086908690611443565b60405180910390a15060019392505050565b6001600160a01b038216600090815260046020526040812080548391908390610c6b908490611494565b925050819055508160036000828254610c849190611494565b90915550506040517fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef906105cf9060009086908690611443565b80516060906000819003610ce2575050604080516020810190915260008152919050565b60006003610cf1836002611494565b610cfb91906114c5565b610d069060046114e7565b90506000610d15826020611494565b67ffffffffffffffff811115610d2d57610d2d6111e5565b6040519080825280601f01601f191660200182016040528015610d57576020820181803683370190505b5090506000604051806060016040528060408152602001611523604091399050600181016020830160005b86811015610de3576003818a01810151603f601282901c8116860151600c83901c8216870151600684901c831688015192909316870151600891821b60ff94851601821b92841692909201901b91160160e01b835260049092019101610d82565b506003860660018114610dfd5760028114610e0e57610e1a565b613d3d60f01b600119830152610e1a565b603d60f81b6000198301525b505050918152949350505050565b60006003821115610e895750806000610e426002836114c5565b610e4d906001611494565b90505b81811015610e8357905080600281610e6881866114c5565b610e729190611494565b610e7c91906114c5565b9050610e50565b50919050565b8115610e93575060015b919050565b600082600003610ede5760405162461bcd60e51b8152602060048201526011602482015270456d70747920636865636b706f696e747360781b6044820152606401610647565b81846000610eed60018761147d565b81526020019081526020016000206000015411610f1657610f0f60018461147d565b90506106a1565b600080805260208590526040902054821015610f34575060006106a1565b600080610f4260018661147d565b90505b81811115610fd55760006002610f5b848461147d565b610f6591906114c5565b610f6f908361147d565b60008181526020898152604091829020825180840190935280548084526001909101549183019190915291925090869003610faf575092506106a1915050565b8051861115610fc057819350610fce565b610fcb60018361147d565b92505b5050610f45565b50949350505050565b60606001600160a01b0384163b6110375760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610647565b600080856001600160a01b0316856040516110529190611506565b6000604051808303816000865af19150503d806000811461108f576040519150601f19603f3d011682016040523d82523d6000602084013e611094565b606091505b50915091506110a48282866110ae565b9695505050505050565b606083156110bd5750816106a1565b8251156110cd5782518084602001fd5b8160405162461bcd60e51b81526004016106479190611117565b60005b838110156111025781810151838201526020016110ea565b83811115611111576000848401525b50505050565b60208152600082518060208401526111368160408501602087016110e7565b601f01601f19169190910160400192915050565b6001600160a01b038116811461075857600080fd5b6000806040838503121561117257600080fd5b823561117d8161114a565b946020939093013593505050565b6000806000606084860312156111a057600080fd5b83356111ab8161114a565b925060208401356111bb8161114a565b929592945050506040919091013590565b6000602082840312156111de57600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b60006020828403121561120d57600080fd5b813567ffffffffffffffff8082111561122557600080fd5b818401915084601f83011261123957600080fd5b81358181111561124b5761124b6111e5565b604051601f8201601f19908116603f01168101908382118183101715611273576112736111e5565b8160405282815287602084870101111561128c57600080fd5b826020860160208301376000928101602001929092525095945050505050565b6000602082840312156112be57600080fd5b81356106a18161114a565b6000806000806000608086880312156112e157600080fd5b85356112ec8161114a565b94506020860135935060408601359250606086013567ffffffffffffffff8082111561131757600080fd5b818801915088601f83011261132b57600080fd5b81358181111561133a57600080fd5b89602082850101111561134c57600080fd5b9699959850939650602001949392505050565b600080600080600080600060e0888a03121561137a57600080fd5b87356113858161114a565b965060208801356113958161114a565b95506040880135945060608801359350608088013560ff811681146113b957600080fd5b9699959850939692959460a0840135945060c09093013592915050565b600080604083850312156113e957600080fd5b82356113f48161114a565b915060208301356114048161114a565b809150509250929050565b600181811c9082168061142357607f821691505b602082108103610e8357634e487b7160e01b600052602260045260246000fd5b6001600160a01b039384168152919092166020820152604081019190915260600190565b634e487b7160e01b600052601160045260246000fd5b60008282101561148f5761148f611467565b500390565b600082198211156114a7576114a7611467565b500190565b6000600182016114be576114be611467565b5060010190565b6000826114e257634e487b7160e01b600052601260045260246000fd5b500490565b600081600019048311821515161561150157611501611467565b500290565b600082516115188184602087016110e7565b919091019291505056fe4142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a303132333435363738392b2fa2646970667358221220d25bbe30bcb02d210266f95c14c48b8981e356e5fa7144655104d87b11940d4364736f6c634300080d0033",
  "deployedBytecode": "0x6080604052600436106101815760003560e01c80637ecebe00116100d1578063a9059cbb1161008a578063d505accf11610064578063d505accf1461043e578063dd62ed3e1461045e578063e3d670d714610496578063fc0c546a146104cc57600080fd5b8063a9059cbb146103f5578063d0e30db014610415578063d294f0931461041d57600080fd5b80637ecebe00146103495780638f5c286a1461037657806392e4dbea1461038b57806395d89b41146103a05780639a7bff79146103b55780639dc29fac146103d557600080fd5b8063313ce5671161013e5780634830155a116101185780634830155a146102c7578063677342ce146102e757806370a08231146103075780637bbdd3771461033457600080fd5b8063313ce5671461027b5780633644e5151461029157806340c10f19146102a757600080fd5b806306fdde0314610186578063095ea7b3146101b157806318160ddd146101e157806323b872dd146102055780632e1a7d4d1461022557806330adf81f14610247575b600080fd5b34801561019257600080fd5b5061019b6104e7565b6040516101a89190611117565b60405180910390f35b3480156101bd57600080fd5b506101d16101cc36600461115f565b610575565b60405190151581526020016101a8565b3480156101ed57600080fd5b506101f760035481565b6040519081526020016101a8565b34801561021157600080fd5b506101d161022036600461118b565b6105e0565b34801561023157600080fd5b506102456102403660046111cc565b6106a8565b005b34801561025357600080fd5b506101f77f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c981565b34801561028757600080fd5b506101f760025481565b34801561029d57600080fd5b506101f760075481565b3480156102b357600080fd5b506101d16102c236600461115f565b610719565b3480156102d357600080fd5b5061019b6102e23660046111fb565b61072f565b3480156102f357600080fd5b506101f76103023660046111cc565b610740565b34801561031357600080fd5b506101f76103223660046112ac565b60046020526000908152604090205481565b34801561034057600080fd5b5061024561074b565b34801561035557600080fd5b506101f76103643660046112ac565b60086020526000908152604090205481565b34801561038257600080fd5b5061024561075b565b34801561039757600080fd5b506102456107c4565b3480156103ac57600080fd5b5061019b6107ea565b3480156103c157600080fd5b506102456103d03660046112c9565b6107f7565b3480156103e157600080fd5b506101d16103f036600461115f565b610885565b34801561040157600080fd5b506101d161041036600461115f565b610900565b61024561090d565b34801561042957600080fd5b506040805160008082526020820152016101a8565b34801561044a57600080fd5b5061024561045936600461135f565b610933565b34801561046a57600080fd5b506101f76104793660046113d6565b600560209081526000928352604080842090915290825290205481565b3480156104a257600080fd5b506101f76104b13660046112ac565b6001600160a01b031660009081526004602052604090205490565b3480156104d857600080fd5b506040513081526020016101a8565b600180546104f49061140f565b80601f01602080910402602001604051908101604052809291908181526020018280546105209061140f565b801561056d5780601f106105425761010080835404028352916020019161056d565b820191906000526020600020905b81548152906001019060200180831161055057829003601f168201915b505050505081565b3360008181526005602090815260408083206001600160a01b03871684529091528082208490555190917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925916105cf919086908690611443565b60405180910390a150600192915050565b6001600160a01b0383166000908152600560209081526040808320338452909152812054828110156106505760405162461bcd60e51b81526020600482015260146024820152734e6f7420656e6f75676820616c6c6f77616e636560601b60448201526064015b60405180910390fd5b6000198114610692576001600160a01b03851660009081526005602090815260408083203384529091528120805485929061068c90849061147d565b90915550505b61069d858585610b9f565b9150505b9392505050565b336000908152600460205260409020548111156106c457600080fd5b33600090815260046020526040812080548392906106e390849061147d565b9091555050604051339082156108fc029083906000818181858888f19350505050158015610715573d6000803e3d6000fd5b5050565b60006107258383610c41565b5060019392505050565b606061073a82610cbe565b92915050565b600061073a82610e28565b6107586006600080610e98565b50565b6040805130602482018190526000196044808401919091528351808403909101815260649092018352602080830180516001600160e01b031663a9059cbb60e01b1790528351808501909452600584526477726f6e6760d81b9084015261075892909190610fde565b604080516020808201835260008083528351918201909352828152610758929190610fde565b600080546104f49061140f565b6000610805828401846112ac565b60405163022c0d9f60e01b8152600060048201819052602482018190523060448301526080606483015260848201529091506001600160a01b0382169063022c0d9f9060a401600060405180830381600087803b15801561086557600080fd5b505af1158015610879573d6000803e3d6000fd5b50505050505050505050565b60008160036000828254610899919061147d565b90915550506001600160a01b038316600090815260046020526040812080548492906108c690849061147d565b90915550506040517fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef906105cf9085906000908690611443565b60006106a1338484610b9f565b336000908152600460205260408120805434929061092c908490611494565b9091555050565b428410156109775760405162461bcd60e51b815260206004820152601160248201527014dd18589b19558c4e8811561412549151607a1b6044820152606401610647565b6007546001600160a01b038816600090815260086020526040812080549192917f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9918b918b918b9190876109ca836114ac565b909155506040805160208101969096526001600160a01b0394851690860152929091166060840152608083015260a082015260c0810187905260e00160405160208183030381529060405280519060200120604051602001610a4392919061190160f01b81526002810192909252602282015260420190565b60408051601f198184030181528282528051602091820120600080855291840180845281905260ff88169284019290925260608301869052608083018590529092509060019060a0016020604051602081039080840390855afa158015610aae573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b03811615801590610ae45750886001600160a01b0316816001600160a01b0316145b610b305760405162461bcd60e51b815260206004820152601b60248201527f537461626c6556313a20494e56414c49445f5349474e415455524500000000006044820152606401610647565b6001600160a01b03808a166000908152600560209081526040808320938c168352929052819020889055517f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92590610b8c908b908b908b90611443565b60405180910390a1505050505050505050565b6001600160a01b038316600090815260046020526040812080548391908390610bc990849061147d565b90915550506001600160a01b03831660009081526004602052604081208054849290610bf6908490611494565b90915550506040517fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef90610c2f90869086908690611443565b60405180910390a15060019392505050565b6001600160a01b038216600090815260046020526040812080548391908390610c6b908490611494565b925050819055508160036000828254610c849190611494565b90915550506040517fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef906105cf9060009086908690611443565b80516060906000819003610ce2575050604080516020810190915260008152919050565b60006003610cf1836002611494565b610cfb91906114c5565b610d069060046114e7565b90506000610d15826020611494565b67ffffffffffffffff811115610d2d57610d2d6111e5565b6040519080825280601f01601f191660200182016040528015610d57576020820181803683370190505b5090506000604051806060016040528060408152602001611523604091399050600181016020830160005b86811015610de3576003818a01810151603f601282901c8116860151600c83901c8216870151600684901c831688015192909316870151600891821b60ff94851601821b92841692909201901b91160160e01b835260049092019101610d82565b506003860660018114610dfd5760028114610e0e57610e1a565b613d3d60f01b600119830152610e1a565b603d60f81b6000198301525b505050918152949350505050565b60006003821115610e895750806000610e426002836114c5565b610e4d906001611494565b90505b81811015610e8357905080600281610e6881866114c5565b610e729190611494565b610e7c91906114c5565b9050610e50565b50919050565b8115610e93575060015b919050565b600082600003610ede5760405162461bcd60e51b8152602060048201526011602482015270456d70747920636865636b706f696e747360781b6044820152606401610647565b81846000610eed60018761147d565b81526020019081526020016000206000015411610f1657610f0f60018461147d565b90506106a1565b600080805260208590526040902054821015610f34575060006106a1565b600080610f4260018661147d565b90505b81811115610fd55760006002610f5b848461147d565b610f6591906114c5565b610f6f908361147d565b60008181526020898152604091829020825180840190935280548084526001909101549183019190915291925090869003610faf575092506106a1915050565b8051861115610fc057819350610fce565b610fcb60018361147d565b92505b5050610f45565b50949350505050565b60606001600160a01b0384163b6110375760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610647565b600080856001600160a01b0316856040516110529190611506565b6000604051808303816000865af19150503d806000811461108f576040519150601f19603f3d011682016040523d82523d6000602084013e611094565b606091505b50915091506110a48282866110ae565b9695505050505050565b606083156110bd5750816106a1565b8251156110cd5782518084602001fd5b8160405162461bcd60e51b81526004016106479190611117565b60005b838110156111025781810151838201526020016110ea565b83811115611111576000848401525b50505050565b60208152600082518060208401526111368160408501602087016110e7565b601f01601f19169190910160400192915050565b6001600160a01b038116811461075857600080fd5b6000806040838503121561117257600080fd5b823561117d8161114a565b946020939093013593505050565b6000806000606084860312156111a057600080fd5b83356111ab8161114a565b925060208401356111bb8161114a565b929592945050506040919091013590565b6000602082840312156111de57600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b60006020828403121561120d57600080fd5b813567ffffffffffffffff8082111561122557600080fd5b818401915084601f83011261123957600080fd5b81358181111561124b5761124b6111e5565b604051601f8201601f19908116603f01168101908382118183101715611273576112736111e5565b8160405282815287602084870101111561128c57600080fd5b826020860160208301376000928101602001929092525095945050505050565b6000602082840312156112be57600080fd5b81356106a18161114a565b6000806000806000608086880312156112e157600080fd5b85356112ec8161114a565b94506020860135935060408601359250606086013567ffffffffffffffff8082111561131757600080fd5b818801915088601f83011261132b57600080fd5b81358181111561133a57600080fd5b89602082850101111561134c57600080fd5b9699959850939650602001949392505050565b600080600080600080600060e0888a03121561137a57600080fd5b87356113858161114a565b965060208801356113958161114a565b95506040880135945060608801359350608088013560ff811681146113b957600080fd5b9699959850939692959460a0840135945060c09093013592915050565b600080604083850312156113e957600080fd5b82356113f48161114a565b915060208301356114048161114a565b809150509250929050565b600181811c9082168061142357607f821691505b602082108103610e8357634e487b7160e01b600052602260045260246000fd5b6001600160a01b039384168152919092166020820152604081019190915260600190565b634e487b7160e01b600052601160045260246000fd5b60008282101561148f5761148f611467565b500390565b600082198211156114a7576114a7611467565b500190565b6000600182016114be576114be611467565b5060010190565b6000826114e257634e487b7160e01b600052601260045260246000fd5b500490565b600081600019048311821515161561150157611501611467565b500290565b600082516115188184602087016110e7565b919091019291505056fe4142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a303132333435363738392b2fa2646970667358221220d25bbe30bcb02d210266f95c14c48b8981e356e5fa7144655104d87b11940d4364736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 30720,
        "contract": "contracts/test/Token.sol:Token",
        "label": "symbol",
        "offset": 0,
        "slot": "0",
        "type": "t_string_storage"
      },
      {
        "astId": 30722,
        "contract": "contracts/test/Token.sol:Token",
        "label": "name",
        "offset": 0,
        "slot": "1",
        "type": "t_string_storage"
      },
      {
        "astId": 30724,
        "contract": "contracts/test/Token.sol:Token",
        "label": "decimals",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 30727,
        "contract": "contracts/test/Token.sol:Token",
        "label": "totalSupply",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 30731,
        "contract": "contracts/test/Token.sol:Token",
        "label": "balanceOf",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 30737,
        "contract": "contracts/test/Token.sol:Token",
        "label": "allowance",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 30742,
        "contract": "contracts/test/Token.sol:Token",
        "label": "_checkpoints",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_uint256,t_struct(Checkpoint)26444_storage)"
      },
      {
        "astId": 30768,
        "contract": "contracts/test/Token.sol:Token",
        "label": "DOMAIN_SEPARATOR",
        "offset": 0,
        "slot": "7",
        "type": "t_bytes32"
      },
      {
        "astId": 30775,
        "contract": "contracts/test/Token.sol:Token",
        "label": "nonces",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_address,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_struct(Checkpoint)26444_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct CheckpointLib.Checkpoint)",
        "numberOfBytes": "32",
        "value": "t_struct(Checkpoint)26444_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Checkpoint)26444_storage": {
        "encoding": "inplace",
        "label": "struct CheckpointLib.Checkpoint",
        "members": [
          {
            "astId": 26441,
            "contract": "contracts/test/Token.sol:Token",
            "label": "timestamp",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 26443,
            "contract": "contracts/test/Token.sol:Token",
            "label": "value",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}