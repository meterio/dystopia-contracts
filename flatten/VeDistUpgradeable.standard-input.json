{
    "language": "Solidity",
    "sources": {
        "contracts/base/vote/VeDistUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../lib/Math.sol\";\nimport \"../../interface/IERC20.sol\";\nimport \"../../interface/IVeDist.sol\";\nimport \"../../interface/IVe.sol\";\nimport \"../../lib/SafeERC20.sol\";\nimport \"../../lib/Initializable.sol\";\n\ncontract VeDistUpgradeable is IVeDist, Initializable {\n    using SafeERC20 for IERC20;\n\n    event CheckpointToken(uint time, uint tokens);\n\n    event Claimed(uint tokenId, uint amount, uint claimEpoch, uint maxEpoch);\n\n    struct ClaimCalculationResult {\n        uint toDistribute;\n        uint userEpoch;\n        uint weekCursor;\n        uint maxUserEpoch;\n        bool success;\n    }\n\n    uint public constant WEEK = 7 * 86400;\n\n    uint public startTime;\n    uint public timeCursor;\n    mapping(uint => uint) public timeCursorOf;\n    mapping(uint => uint) public userEpochOf;\n\n    uint public lastTokenTime;\n    uint[1000000000000000] public tokensPerWeek;\n\n    address public votingEscrow;\n    address public token;\n    uint public tokenLastBalance;\n\n    uint[1000000000000000] public veSupply;\n\n    address public depositor;\n\n    function initialize(address _votingEscrow, address _depositor)\n        public\n        initializer\n    {\n        uint _t = (block.timestamp / WEEK) * WEEK;\n        startTime = _t;\n        lastTokenTime = _t;\n        timeCursor = _t;\n        address _token = IVe(_votingEscrow).token();\n        token = _token;\n        votingEscrow = _votingEscrow;\n        depositor = _depositor;\n        IERC20(_token).safeIncreaseAllowance(_votingEscrow, type(uint).max);\n    }\n\n    function timestamp() external view returns (uint) {\n        return (block.timestamp / WEEK) * WEEK;\n    }\n\n    function _checkpointToken() internal {\n        uint tokenBalance = IERC20(token).balanceOf(address(this));\n        uint toDistribute = tokenBalance - tokenLastBalance;\n        tokenLastBalance = tokenBalance;\n\n        uint t = lastTokenTime;\n        uint sinceLast = block.timestamp - t;\n        lastTokenTime = block.timestamp;\n        uint thisWeek = (t / WEEK) * WEEK;\n        uint nextWeek = 0;\n\n        for (uint i = 0; i < 20; i++) {\n            nextWeek = thisWeek + WEEK;\n            if (block.timestamp < nextWeek) {\n                tokensPerWeek[thisWeek] += _adjustToDistribute(\n                    toDistribute,\n                    block.timestamp,\n                    t,\n                    sinceLast\n                );\n                break;\n            } else {\n                tokensPerWeek[thisWeek] += _adjustToDistribute(\n                    toDistribute,\n                    nextWeek,\n                    t,\n                    sinceLast\n                );\n            }\n            t = nextWeek;\n            thisWeek = nextWeek;\n        }\n        emit CheckpointToken(block.timestamp, toDistribute);\n    }\n\n    /// @dev For testing purposes.\n    function adjustToDistribute(\n        uint toDistribute,\n        uint t0,\n        uint t1,\n        uint sinceLastCall\n    ) external pure returns (uint) {\n        return _adjustToDistribute(toDistribute, t0, t1, sinceLastCall);\n    }\n\n    function _adjustToDistribute(\n        uint toDistribute,\n        uint t0,\n        uint t1,\n        uint sinceLast\n    ) internal pure returns (uint) {\n        if (t0 <= t1 || t0 - t1 == 0 || sinceLast == 0) {\n            return toDistribute;\n        }\n        return (toDistribute * (t0 - t1)) / sinceLast;\n    }\n\n    function checkpointToken() external override {\n        require(msg.sender == depositor, \"!depositor\");\n        _checkpointToken();\n    }\n\n    function _findTimestampEpoch(address ve, uint _timestamp)\n        internal\n        view\n        returns (uint)\n    {\n        uint _min = 0;\n        uint _max = IVe(ve).epoch();\n        for (uint i = 0; i < 128; i++) {\n            if (_min >= _max) break;\n            uint _mid = (_min + _max + 2) / 2;\n            IVe.Point memory pt = IVe(ve).pointHistory(_mid);\n            if (pt.ts <= _timestamp) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    function findTimestampUserEpoch(\n        address ve,\n        uint tokenId,\n        uint _timestamp,\n        uint maxUserEpoch\n    ) external view returns (uint) {\n        return _findTimestampUserEpoch(ve, tokenId, _timestamp, maxUserEpoch);\n    }\n\n    function _findTimestampUserEpoch(\n        address ve,\n        uint tokenId,\n        uint _timestamp,\n        uint maxUserEpoch\n    ) internal view returns (uint) {\n        uint _min = 0;\n        uint _max = maxUserEpoch;\n        for (uint i = 0; i < 128; i++) {\n            if (_min >= _max) break;\n            uint _mid = (_min + _max + 2) / 2;\n            IVe.Point memory pt = IVe(ve).userPointHistory(tokenId, _mid);\n            if (pt.ts <= _timestamp) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    function veForAt(uint _tokenId, uint _timestamp)\n        external\n        view\n        returns (uint)\n    {\n        address ve = votingEscrow;\n        uint maxUserEpoch = IVe(ve).userPointEpoch(_tokenId);\n        uint epoch = _findTimestampUserEpoch(\n            ve,\n            _tokenId,\n            _timestamp,\n            maxUserEpoch\n        );\n        IVe.Point memory pt = IVe(ve).userPointHistory(_tokenId, epoch);\n        return\n            uint(\n                int256(\n                    Math.positiveInt128(\n                        pt.bias -\n                            pt.slope *\n                            (int128(int256(_timestamp - pt.ts)))\n                    )\n                )\n            );\n    }\n\n    function _checkpointTotalSupply() internal {\n        address ve = votingEscrow;\n        uint t = timeCursor;\n        uint roundedTimestamp = (block.timestamp / WEEK) * WEEK;\n        IVe(ve).checkpoint();\n\n        // assume will be called more frequently than 20 weeks\n        for (uint i = 0; i < 20; i++) {\n            if (t > roundedTimestamp) {\n                break;\n            } else {\n                uint epoch = _findTimestampEpoch(ve, t);\n                IVe.Point memory pt = IVe(ve).pointHistory(epoch);\n                veSupply[t] = _adjustVeSupply(t, pt.ts, pt.bias, pt.slope);\n            }\n            t += WEEK;\n        }\n        timeCursor = t;\n    }\n\n    function adjustVeSupply(\n        uint t,\n        uint ptTs,\n        int128 ptBias,\n        int128 ptSlope\n    ) external pure returns (uint) {\n        return _adjustVeSupply(t, ptTs, ptBias, ptSlope);\n    }\n\n    function _adjustVeSupply(\n        uint t,\n        uint ptTs,\n        int128 ptBias,\n        int128 ptSlope\n    ) internal pure returns (uint) {\n        if (t < ptTs) {\n            return 0;\n        }\n        int128 dt = int128(int256(t - ptTs));\n        if (ptBias < ptSlope * dt) {\n            return 0;\n        }\n        return uint(int256(Math.positiveInt128(ptBias - ptSlope * dt)));\n    }\n\n    function checkpointTotalSupply() external override {\n        _checkpointTotalSupply();\n    }\n\n    function _claim(\n        uint _tokenId,\n        address ve,\n        uint _lastTokenTime\n    ) internal returns (uint) {\n        ClaimCalculationResult memory result = _calculateClaim(\n            _tokenId,\n            ve,\n            _lastTokenTime\n        );\n        if (result.success) {\n            userEpochOf[_tokenId] = result.userEpoch;\n            timeCursorOf[_tokenId] = result.weekCursor;\n            emit Claimed(\n                _tokenId,\n                result.toDistribute,\n                result.userEpoch,\n                result.maxUserEpoch\n            );\n        }\n        return result.toDistribute;\n    }\n\n    function calculateClaim(uint _tokenId, uint _lastTokenTime)\n        public\n        view\n        returns (ClaimCalculationResult memory)\n    {\n        return _calculateClaim(_tokenId, votingEscrow, _lastTokenTime);\n    }\n\n    function _calculateClaim(\n        uint _tokenId,\n        address ve,\n        uint _lastTokenTime\n    ) internal view returns (ClaimCalculationResult memory) {\n        uint userEpoch;\n        uint toDistribute;\n        uint maxUserEpoch = IVe(ve).userPointEpoch(_tokenId);\n        uint _startTime = startTime;\n\n        if (maxUserEpoch == 0) {\n            return ClaimCalculationResult(0, 0, 0, 0, false);\n        }\n\n        uint weekCursor = timeCursorOf[_tokenId];\n\n        if (weekCursor == 0) {\n            userEpoch = _findTimestampUserEpoch(\n                ve,\n                _tokenId,\n                _startTime,\n                maxUserEpoch\n            );\n        } else {\n            userEpoch = userEpochOf[_tokenId];\n        }\n\n        if (userEpoch == 0) userEpoch = 1;\n\n        IVe.Point memory userPoint = IVe(ve).userPointHistory(\n            _tokenId,\n            userEpoch\n        );\n        if (weekCursor == 0) {\n            weekCursor = ((userPoint.ts + WEEK - 1) / WEEK) * WEEK;\n        }\n        if (weekCursor >= lastTokenTime) {\n            return ClaimCalculationResult(0, 0, 0, 0, false);\n        }\n        if (weekCursor < _startTime) {\n            weekCursor = _startTime;\n        }\n\n        IVe.Point memory oldUserPoint;\n        {\n            for (uint i = 0; i < 50; i++) {\n                if (weekCursor >= _lastTokenTime) {\n                    break;\n                }\n                if (weekCursor >= userPoint.ts && userEpoch <= maxUserEpoch) {\n                    userEpoch += 1;\n                    oldUserPoint = userPoint;\n                    if (userEpoch > maxUserEpoch) {\n                        userPoint = IVe.Point(0, 0, 0, 0);\n                    } else {\n                        userPoint = IVe(ve).userPointHistory(\n                            _tokenId,\n                            userEpoch\n                        );\n                    }\n                } else {\n                    int128 dt = int128(int256(weekCursor - oldUserPoint.ts));\n                    uint balanceOf = uint(\n                        int256(\n                            Math.positiveInt128(\n                                oldUserPoint.bias - dt * oldUserPoint.slope\n                            )\n                        )\n                    );\n                    if (balanceOf == 0 && userEpoch > maxUserEpoch) {\n                        break;\n                    }\n                    toDistribute +=\n                        (balanceOf * tokensPerWeek[weekCursor]) /\n                        veSupply[weekCursor];\n                    weekCursor += WEEK;\n                }\n            }\n        }\n        return\n            ClaimCalculationResult(\n                toDistribute,\n                Math.min(maxUserEpoch, userEpoch - 1),\n                weekCursor,\n                maxUserEpoch,\n                true\n            );\n    }\n\n    function claimable(uint _tokenId) external view returns (uint) {\n        uint _lastTokenTime = (lastTokenTime / WEEK) * WEEK;\n        ClaimCalculationResult memory result = _calculateClaim(\n            _tokenId,\n            votingEscrow,\n            _lastTokenTime\n        );\n        return result.toDistribute;\n    }\n\n    function claim(uint _tokenId) external returns (uint) {\n        if (block.timestamp >= timeCursor) _checkpointTotalSupply();\n        uint _lastTokenTime = lastTokenTime;\n        _lastTokenTime = (_lastTokenTime / WEEK) * WEEK;\n        uint amount = _claim(_tokenId, votingEscrow, _lastTokenTime);\n        if (amount != 0) {\n            IVe(votingEscrow).depositFor(_tokenId, amount);\n            tokenLastBalance -= amount;\n        }\n        return amount;\n    }\n\n    function claimMany(uint[] memory _tokenIds) external returns (bool) {\n        if (block.timestamp >= timeCursor) _checkpointTotalSupply();\n        uint _lastTokenTime = lastTokenTime;\n        _lastTokenTime = (_lastTokenTime / WEEK) * WEEK;\n        address _votingEscrow = votingEscrow;\n        uint total = 0;\n\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            uint _tokenId = _tokenIds[i];\n            if (_tokenId == 0) break;\n            uint amount = _claim(_tokenId, _votingEscrow, _lastTokenTime);\n            if (amount != 0) {\n                IVe(_votingEscrow).depositFor(_tokenId, amount);\n                total += amount;\n            }\n        }\n        if (total != 0) {\n            tokenLastBalance -= total;\n        }\n\n        return true;\n    }\n\n    // Once off event on contract initialize\n    function setDepositor(address _depositor) external {\n        require(msg.sender == depositor, \"!depositor\");\n        depositor = _depositor;\n    }\n}\n"
        },
        "contracts/lib/Initializable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.13;\n\nimport \"./Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
        },
        "contracts/lib/SafeERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.13;\n\nimport \"../interface/IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint value\n    ) internal {\n        uint newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n"
        },
        "contracts/interface/IVe.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IVe {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME,\n        MERGE_TYPE\n    }\n\n    struct Point {\n        int128 bias;\n        int128 slope; // # -dweight / dt\n        uint ts;\n        uint blk; // block\n    }\n    /* We cannot really do block numbers per se b/c slope is per time, not per block\n     * and per block could be fairly bad b/c Ethereum changes blocktimes.\n     * What we can do is to extrapolate ***At functions */\n\n    struct LockedBalance {\n        int128 amount;\n        uint end;\n    }\n\n    function token() external view returns (address);\n\n    function balanceOfNFT(uint) external view returns (uint);\n\n    function isApprovedOrOwner(address, uint) external view returns (bool);\n\n    function createLockFor(\n        uint,\n        uint,\n        address\n    ) external returns (uint);\n\n    function userPointEpoch(uint tokenId) external view returns (uint);\n\n    function epoch() external view returns (uint);\n\n    function userPointHistory(uint tokenId, uint loc)\n        external\n        view\n        returns (Point memory);\n\n    function pointHistory(uint loc) external view returns (Point memory);\n\n    function checkpoint() external;\n\n    function depositFor(uint tokenId, uint value) external;\n\n    function attachToken(uint tokenId) external;\n\n    function detachToken(uint tokenId) external;\n\n    function voting(uint tokenId) external;\n\n    function abstain(uint tokenId) external;\n}\n"
        },
        "contracts/interface/IVeDist.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IVeDist {\n    function checkpointToken() external;\n\n    function checkpointTotalSupply() external;\n}\n"
        },
        "contracts/interface/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
        },
        "contracts/lib/Math.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nlibrary Math {\n    function max(uint a, uint b) internal pure returns (uint) {\n        return a >= b ? a : b;\n    }\n\n    function min(uint a, uint b) internal pure returns (uint) {\n        return a < b ? a : b;\n    }\n\n    function positiveInt128(int128 value) internal pure returns (int128) {\n        return value < 0 ? int128(0) : value;\n    }\n\n    function closeTo(\n        uint a,\n        uint b,\n        uint target\n    ) internal pure returns (bool) {\n        if (a > b) {\n            if (a - b <= target) {\n                return true;\n            }\n        } else {\n            if (b - a <= target) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
        },
        "contracts/lib/Address.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.13;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n}\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "": [
                    "ast"
                ],
                "*": [
                    "abi",
                    "metadata",
                    "devdoc",
                    "userdoc",
                    "storageLayout",
                    "evm.legacyAssembly",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "evm.gasEstimates",
                    "evm.assembly"
                ]
            }
        }
    }
}