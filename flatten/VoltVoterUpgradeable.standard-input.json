{
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "": ["ast"],
        "*": [
          "abi",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.legacyAssembly",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "evm.gasEstimates",
          "evm.assembly"
        ]
      }
    }
  },
  "sources": {
    "contracts/base/vote/VoltVoterUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../interface/IVe.sol\";\nimport \"../../interface/IVoter.sol\";\nimport \"../../interface/IERC20.sol\";\nimport \"../../interface/IERC721.sol\";\nimport \"../../interface/IGauge.sol\";\nimport \"../../interface/IFactory.sol\";\nimport \"../../interface/IPair.sol\";\nimport \"../../interface/IBribeFactory.sol\";\nimport \"../../interface/IGaugeFactory.sol\";\nimport \"../../interface/IMinter.sol\";\nimport \"../../interface/IBribe.sol\";\nimport \"../../interface/IMultiRewardsPool.sol\";\nimport \"../Reentrancy.sol\";\nimport \"../../lib/SafeERC20.sol\";\nimport \"../../lib/Initializable.sol\";\n\ncontract VoltVoterUpgradeable is IVoter, Reentrancy, Initializable {\n    using SafeERC20 for IERC20;\n\n    /// @dev The ve token that governs these contracts\n    address public override ve;\n    /// @dev VoltFactory\n    address public factory;\n    address public token;\n    address public gaugeFactory;\n    address public bribeFactory;\n    /// @dev Rewards are released over 7 days\n    uint internal constant DURATION = 7 days;\n    address public minter;\n\n    /// @dev Total voting weight\n    uint public totalWeight;\n\n    /// @dev All pools viable for incentives\n    address[] public pools;\n    /// @dev pool => gauge\n    mapping(address => address) public gauges;\n    /// @dev gauge => pool\n    mapping(address => address) public poolForGauge;\n    /// @dev gauge => bribe\n    mapping(address => address) public bribes;\n    /// @dev pool => weight\n    mapping(address => int256) public weights;\n    /// @dev nft => pool => votes\n    mapping(uint => mapping(address => int256)) public votes;\n    /// @dev nft => pools\n    mapping(uint => address[]) public poolVote;\n    /// @dev nft => total voting weight of user\n    mapping(uint => uint) public usedWeights;\n    mapping(address => bool) public isGauge;\n    mapping(address => bool) public isWhitelisted;\n\n    uint public index;\n    mapping(address => uint) public supplyIndex;\n    mapping(address => uint) public claimable;\n\n    event GaugeCreated(\n        address indexed gauge,\n        address creator,\n        address indexed bribe,\n        address indexed pool\n    );\n    event Voted(address indexed voter, uint tokenId, int256 weight);\n    event Abstained(uint tokenId, int256 weight);\n    event Deposit(\n        address indexed lp,\n        address indexed gauge,\n        uint tokenId,\n        uint amount\n    );\n    event Withdraw(\n        address indexed lp,\n        address indexed gauge,\n        uint tokenId,\n        uint amount\n    );\n    event NotifyReward(\n        address indexed sender,\n        address indexed reward,\n        uint amount\n    );\n    event DistributeReward(\n        address indexed sender,\n        address indexed gauge,\n        uint amount\n    );\n    event Attach(address indexed owner, address indexed gauge, uint tokenId);\n    event Detach(address indexed owner, address indexed gauge, uint tokenId);\n    event Whitelisted(address indexed whitelister, address indexed token);\n    event RemoveWhitelist(address indexed whitelister, address indexed token);\n\n    function initialize(\n        address _ve,\n        address _factory,\n        address _gaugeFactory,\n        address _bribeFactory,\n        address _minter\n    ) public initializer {\n        ve = _ve;\n        factory = _factory;\n        token = IVe(_ve).token();\n        gaugeFactory = _gaugeFactory;\n        bribeFactory = _bribeFactory;\n        minter = _minter;\n        _unlocked = 1;\n    }\n\n    function init(address[] memory _tokens, address _minter) external {\n        require(msg.sender == minter, \"!minter\");\n        for (uint i = 0; i < _tokens.length; i++) {\n            _whitelist(_tokens[i]);\n        }\n        minter = _minter;\n    }\n\n    function removeWhitelist(address[] memory _tokens) external {\n        require(msg.sender == minter, \"!minter\");\n        for (uint i = 0; i < _tokens.length; i++) {\n            address _token = _tokens[i];\n            require(isWhitelisted[_token], \"already whitelisted\");\n            isWhitelisted[_token] = false;\n            emit Whitelisted(msg.sender, _token);\n        }\n    }\n\n    /// @dev Amount of tokens required to be hold for whitelisting.\n    function listingFee() external view returns (uint) {\n        return _listingFee();\n    }\n\n    /// @dev 20% of circulation supply.\n    function _listingFee() internal view returns (uint) {\n        return\n            (IERC20(token).totalSupply() -\n                IERC20(ve).totalSupply() -\n                IERC20(token).balanceOf(minter)) / 20;\n    }\n\n    /// @dev Remove all votes for given tokenId.\n    function reset(uint _tokenId) external {\n        require(IVe(ve).isApprovedOrOwner(msg.sender, _tokenId), \"!owner\");\n        _reset(_tokenId);\n        IVe(ve).abstain(_tokenId);\n    }\n\n    function _reset(uint _tokenId) internal {\n        address[] storage _poolVote = poolVote[_tokenId];\n        uint _poolVoteCnt = _poolVote.length;\n        int256 _totalWeight = 0;\n\n        for (uint i = 0; i < _poolVoteCnt; i++) {\n            address _pool = _poolVote[i];\n            int256 _votes = votes[_tokenId][_pool];\n            _updateFor(gauges[_pool]);\n            weights[_pool] -= _votes;\n            votes[_tokenId][_pool] -= _votes;\n            if (_votes > 0) {\n                IBribe(bribes[gauges[_pool]])._withdraw(uint(_votes), _tokenId);\n                _totalWeight += _votes;\n            } else {\n                _totalWeight -= _votes;\n            }\n            emit Abstained(_tokenId, _votes);\n        }\n        totalWeight -= uint(_totalWeight);\n        usedWeights[_tokenId] = 0;\n        delete poolVote[_tokenId];\n    }\n\n    /// @dev Resubmit exist votes for given token. For internal purposes.\n    function poke(uint _tokenId) external {\n        address[] memory _poolVote = poolVote[_tokenId];\n        uint _poolCnt = _poolVote.length;\n        int256[] memory _weights = new int256[](_poolCnt);\n        int256 _totalVoteWeight = 0;\n\n        for (uint i = 0; i < _poolCnt; i++) {\n            _weights[i] = votes[_tokenId][_poolVote[i]];\n            _totalVoteWeight += _weights[i] > 0 ? _weights[i] : -_weights[i];\n        }\n\n        _vote(_tokenId, _poolVote, _weights, _totalVoteWeight);\n    }\n\n    function _vote(\n        uint _tokenId,\n        address[] memory _poolVote,\n        int256[] memory _weights,\n        int256 _totalVoteWeight\n    ) internal {\n        _reset(_tokenId);\n        uint _poolCnt = _poolVote.length;\n        int256 _weight = int256(IVe(ve).balanceOfNFT(_tokenId));\n        int256 _totalWeight = 0;\n        int256 _usedWeight = 0;\n\n        for (uint i = 0; i < _poolCnt; i++) {\n            address _pool = _poolVote[i];\n            address _gauge = gauges[_pool];\n\n            int256 _poolWeight = (_weights[i] * _weight) / _totalVoteWeight;\n            require(votes[_tokenId][_pool] == 0, \"duplicate pool\");\n            require(_poolWeight != 0, \"zero power\");\n            _updateFor(_gauge);\n\n            poolVote[_tokenId].push(_pool);\n\n            weights[_pool] += _poolWeight;\n            votes[_tokenId][_pool] += _poolWeight;\n            if (_poolWeight > 0) {\n                IBribe(bribes[_gauge])._deposit(uint(_poolWeight), _tokenId);\n            } else {\n                _poolWeight = -_poolWeight;\n            }\n            _usedWeight += _poolWeight;\n            _totalWeight += _poolWeight;\n            emit Voted(msg.sender, _tokenId, _poolWeight);\n        }\n        if (_usedWeight > 0) IVe(ve).voting(_tokenId);\n        totalWeight += uint(_totalWeight);\n        usedWeights[_tokenId] = uint(_usedWeight);\n    }\n\n    /// @dev Vote for given pools using a vote power of given tokenId. Reset previous votes.\n    function vote(\n        uint tokenId,\n        address[] calldata _poolVote,\n        int256[] calldata _weights\n    ) external {\n        require(IVe(ve).isApprovedOrOwner(msg.sender, tokenId), \"!owner\");\n        require(_poolVote.length == _weights.length, \"!arrays\");\n        int256 _totalVoteWeight = 0;\n        for (uint i = 0; i < _poolVote.length; i++) {\n            _totalVoteWeight += _weights[i] > 0 ? _weights[i] : -_weights[i];\n        }\n        _vote(tokenId, _poolVote, _weights, _totalVoteWeight);\n    }\n\n    function votePart(\n        uint tokenId,\n        address[] calldata _poolVote,\n        int256[] calldata _weights\n    ) external {\n        require(IVe(ve).isApprovedOrOwner(msg.sender, tokenId), \"!owner\");\n        require(_poolVote.length == _weights.length, \"!arrays\");\n        int256 _totalVoteWeight = 0;\n        for (uint i = 0; i < _poolVote.length; i++) {\n            _totalVoteWeight += _weights[i] > 0 ? _weights[i] : -_weights[i];\n        }\n        require(_totalVoteWeight <= 100, \"totalVoteWeight\");\n        _totalVoteWeight = 100;\n        _vote(tokenId, _poolVote, _weights, _totalVoteWeight);\n    }\n\n    /// @dev Add token to whitelist. Only pools with whitelisted tokens can be added to gauge.\n    function whitelist(address _token, uint _tokenId) external {\n        require(_tokenId > 0, \"!token\");\n        require(msg.sender == IERC721(ve).ownerOf(_tokenId), \"!owner\");\n        require(IVe(ve).balanceOfNFT(_tokenId) > _listingFee(), \"!power\");\n        _whitelist(_token);\n    }\n\n    function _whitelist(address _token) internal {\n        require(!isWhitelisted[_token], \"already whitelisted\");\n        isWhitelisted[_token] = true;\n        emit Whitelisted(msg.sender, _token);\n    }\n\n    /// @dev Add a token to a gauge/bribe as possible reward.\n    function registerRewardToken(\n        address _token,\n        address _gaugeOrBribe,\n        uint _tokenId\n    ) external {\n        require(_tokenId > 0, \"!token\");\n        require(msg.sender == IERC721(ve).ownerOf(_tokenId), \"!owner\");\n        require(IVe(ve).balanceOfNFT(_tokenId) > _listingFee(), \"!power\");\n        IMultiRewardsPool(_gaugeOrBribe).registerRewardToken(_token);\n    }\n\n    /// @dev Remove a token from a gauge/bribe allowed rewards list.\n    function removeRewardToken(\n        address _token,\n        address _gaugeOrBribe,\n        uint _tokenId\n    ) external {\n        require(_tokenId > 0, \"!token\");\n        require(msg.sender == IERC721(ve).ownerOf(_tokenId), \"!owner\");\n        require(IVe(ve).balanceOfNFT(_tokenId) > _listingFee(), \"!power\");\n        IMultiRewardsPool(_gaugeOrBribe).removeRewardToken(_token);\n    }\n\n    /// @dev Create gauge for given pool. Only for a pool with whitelisted tokens.\n    function createGauge(address _pool) external returns (address) {\n        require(gauges[_pool] == address(0x0), \"exists\");\n        require(IFactory(factory).isPair(_pool), \"!pool\");\n        (address tokenA, address tokenB) = IPair(_pool).tokens();\n        require(isWhitelisted[tokenA] && isWhitelisted[tokenB], \"!whitelisted\");\n\n        address[] memory allowedRewards = new address[](3);\n        allowedRewards[0] = tokenA;\n        allowedRewards[1] = tokenB;\n        if (token != tokenA && token != tokenB) {\n            allowedRewards[2] = token;\n        }\n\n        address _bribe = IBribeFactory(bribeFactory).createBribe(\n            allowedRewards\n        );\n        address _gauge = IGaugeFactory(gaugeFactory).createGauge(\n            _pool,\n            _bribe,\n            ve,\n            allowedRewards\n        );\n        IERC20(token).safeIncreaseAllowance(_gauge, type(uint).max);\n        bribes[_gauge] = _bribe;\n        gauges[_pool] = _gauge;\n        poolForGauge[_gauge] = _pool;\n        isGauge[_gauge] = true;\n        _updateFor(_gauge);\n        pools.push(_pool);\n        emit GaugeCreated(_gauge, msg.sender, _bribe, _pool);\n        return _gauge;\n    }\n\n    /// @dev A gauge should be able to attach a token for preventing transfers/withdraws.\n    function attachTokenToGauge(\n        uint tokenId,\n        address account\n    ) external override {\n        require(isGauge[msg.sender], \"!gauge\");\n        if (tokenId > 0) {\n            IVe(ve).attachToken(tokenId);\n        }\n        emit Attach(account, msg.sender, tokenId);\n    }\n\n    /// @dev Emit deposit event for easily handling external actions.\n    function emitDeposit(\n        uint tokenId,\n        address account,\n        uint amount\n    ) external override {\n        require(isGauge[msg.sender], \"!gauge\");\n        emit Deposit(account, msg.sender, tokenId, amount);\n    }\n\n    /// @dev Detach given token.\n    function detachTokenFromGauge(\n        uint tokenId,\n        address account\n    ) external override {\n        require(isGauge[msg.sender], \"!gauge\");\n        if (tokenId > 0) {\n            IVe(ve).detachToken(tokenId);\n        }\n        emit Detach(account, msg.sender, tokenId);\n    }\n\n    /// @dev Emit withdraw event for easily handling external actions.\n    function emitWithdraw(\n        uint tokenId,\n        address account,\n        uint amount\n    ) external override {\n        require(isGauge[msg.sender], \"!gauge\");\n        emit Withdraw(account, msg.sender, tokenId, amount);\n    }\n\n    /// @dev Length of pools\n    function poolsLength() external view returns (uint) {\n        return pools.length;\n    }\n\n    /// @dev Add rewards to this contract. Usually it is VoltMinter.\n    function notifyRewardAmount(uint amount) external override {\n        require(amount != 0, \"zero amount\");\n        uint _totalWeight = totalWeight;\n        // without votes rewards can not be added\n        require(_totalWeight != 0, \"!weights\");\n        // transfer the distro in\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        // 1e18 adjustment is removed during claim\n        uint _ratio = (amount * 1e18) / _totalWeight;\n        if (_ratio > 0) {\n            index += _ratio;\n        }\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    /// @dev Update given gauges.\n    function updateFor(address[] memory _gauges) external {\n        for (uint i = 0; i < _gauges.length; i++) {\n            _updateFor(_gauges[i]);\n        }\n    }\n\n    /// @dev Update gauges by indexes in a range.\n    function updateForRange(uint start, uint end) public {\n        for (uint i = start; i < end; i++) {\n            _updateFor(gauges[pools[i]]);\n        }\n    }\n\n    /// @dev Update all gauges.\n    function updateAll() external {\n        updateForRange(0, pools.length);\n    }\n\n    /// @dev Update reward info for given gauge.\n    function updateGauge(address _gauge) external {\n        _updateFor(_gauge);\n    }\n\n    function _updateFor(address _gauge) internal {\n        address _pool = poolForGauge[_gauge];\n        int256 _supplied = weights[_pool];\n        if (_supplied > 0) {\n            uint _supplyIndex = supplyIndex[_gauge];\n            // get global index for accumulated distro\n            uint _index = index;\n            // update _gauge current position to global position\n            supplyIndex[_gauge] = _index;\n            // see if there is any difference that need to be accrued\n            uint _delta = _index - _supplyIndex;\n            if (_delta > 0) {\n                // add accrued difference for each supplied token\n                uint _share = (uint(_supplied) * _delta) / 1e18;\n                claimable[_gauge] += _share;\n            }\n        } else {\n            // new users are set to the default global state\n            supplyIndex[_gauge] = index;\n        }\n    }\n\n    /// @dev Batch claim rewards from given gauges.\n    function claimRewards(\n        address[] memory _gauges,\n        address[][] memory _tokens\n    ) external {\n        for (uint i = 0; i < _gauges.length; i++) {\n            IGauge(_gauges[i]).getReward(msg.sender, _tokens[i]);\n        }\n    }\n\n    /// @dev Batch claim rewards from given bribe contracts for given tokenId.\n    function claimBribes(\n        address[] memory _bribes,\n        address[][] memory _tokens,\n        uint _tokenId\n    ) external {\n        require(IVe(ve).isApprovedOrOwner(msg.sender, _tokenId), \"!owner\");\n        for (uint i = 0; i < _bribes.length; i++) {\n            IBribe(_bribes[i]).getRewardForOwner(_tokenId, _tokens[i]);\n        }\n    }\n\n    /// @dev Claim fees from given bribes.\n    function claimFees(\n        address[] memory _bribes,\n        address[][] memory _tokens,\n        uint _tokenId\n    ) external {\n        require(IVe(ve).isApprovedOrOwner(msg.sender, _tokenId), \"!owner\");\n        for (uint i = 0; i < _bribes.length; i++) {\n            IBribe(_bribes[i]).getRewardForOwner(_tokenId, _tokens[i]);\n        }\n    }\n\n    /// @dev Move fees from deposited pools to bribes for given gauges.\n    function distributeFees(address[] memory _gauges) external {\n        for (uint i = 0; i < _gauges.length; i++) {\n            IGauge(_gauges[i]).claimFees();\n        }\n    }\n\n    /// @dev Get emission from minter and notify rewards for given gauge.\n    function distribute(address _gauge) external override {\n        _distribute(_gauge);\n    }\n\n    function _distribute(address _gauge) internal lock {\n        IMinter(minter).updatePeriod();\n        _updateFor(_gauge);\n        uint _claimable = claimable[_gauge];\n        if (\n            _claimable > IMultiRewardsPool(_gauge).left(token) &&\n            _claimable / DURATION > 0\n        ) {\n            claimable[_gauge] = 0;\n            IGauge(_gauge).notifyRewardAmount(token, _claimable);\n            emit DistributeReward(msg.sender, _gauge, _claimable);\n        }\n    }\n\n    /// @dev Distribute rewards for all pools.\n    function distributeAll() external {\n        uint length = pools.length;\n        for (uint x; x < length; x++) {\n            _distribute(gauges[pools[x]]);\n        }\n    }\n\n    function distributeForPoolsInRange(uint start, uint finish) external {\n        for (uint x = start; x < finish; x++) {\n            _distribute(gauges[pools[x]]);\n        }\n    }\n\n    function distributeForGauges(address[] memory _gauges) external {\n        for (uint x = 0; x < _gauges.length; x++) {\n            _distribute(_gauges[x]);\n        }\n    }\n}\n"
    },
    "contracts/lib/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.13;\n\nimport \"./Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "contracts/lib/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.13;\n\nimport \"../interface/IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint value\n    ) internal {\n        uint newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/base/Reentrancy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nabstract contract Reentrancy {\n    /// @dev simple re-entrancy check\n    uint internal _unlocked = 1;\n\n    modifier lock() {\n        require(_unlocked == 1, \"Reentrant call\");\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n}\n"
    },
    "contracts/interface/IMultiRewardsPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IMultiRewardsPool {\n    function underlying() external view returns (address);\n\n    function derivedSupply() external view returns (uint);\n\n    function derivedBalances(address account) external view returns (uint);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function rewardTokens(uint id) external view returns (address);\n\n    function isRewardToken(address token) external view returns (bool);\n\n    function rewardTokensLength() external view returns (uint);\n\n    function derivedBalance(address account) external view returns (uint);\n\n    function left(address token) external view returns (uint);\n\n    function earned(address token, address account)\n        external\n        view\n        returns (uint);\n\n    function registerRewardToken(address token) external;\n\n    function removeRewardToken(address token) external;\n}\n"
    },
    "contracts/interface/IBribe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IBribe {\n    function notifyRewardAmount(address token, uint amount) external;\n\n    function _deposit(uint amount, uint tokenId) external;\n\n    function _withdraw(uint amount, uint tokenId) external;\n\n    function getRewardForOwner(uint tokenId, address[] memory tokens) external;\n}\n"
    },
    "contracts/interface/IMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IMinter {\n    function updatePeriod() external returns (uint);\n}\n"
    },
    "contracts/interface/IGaugeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IGaugeFactory {\n    function createGauge(\n        address _pool,\n        address _bribe,\n        address _ve,\n        address[] memory _allowedRewardTokens\n    ) external returns (address);\n\n    function createGaugeSingle(\n        address _pool,\n        address _bribe,\n        address _ve,\n        address _voter,\n        address[] memory _allowedRewardTokens\n    ) external returns (address);\n}\n"
    },
    "contracts/interface/IBribeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IBribeFactory {\n    function createBribe(address[] memory _allowedRewardTokens)\n        external\n        returns (address);\n}\n"
    },
    "contracts/interface/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IPair {\n    // Structure to capture time period obervations every 30 minutes, used for local oracles\n    struct Observation {\n        uint timestamp;\n        uint reserve0Cumulative;\n        uint reserve1Cumulative;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function burn(address to) external returns (uint amount0, uint amount1);\n\n    function mint(address to) external returns (uint liquidity);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        );\n\n    function getAmountOut(uint, address) external view returns (uint);\n\n    function claimFees() external returns (uint, uint);\n\n    function tokens() external view returns (address, address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function stable() external view returns (bool);\n\n    function metadata()\n        external\n        view\n        returns (\n            uint dec0,\n            uint dec1,\n            uint r0,\n            uint r1,\n            bool st,\n            address t0,\n            address t1\n        );\n}\n"
    },
    "contracts/interface/IFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IFactory {\n    function treasury() external view returns (address);\n\n    function isPair(address pair) external view returns (bool);\n\n    function getInitializable()\n        external\n        view\n        returns (\n            address,\n            address,\n            bool\n        );\n\n    function isPaused() external view returns (bool);\n\n    function pairCodeHash() external pure returns (bytes32);\n\n    function getPair(\n        address tokenA,\n        address token,\n        bool stable\n    ) external view returns (address);\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external returns (address pair);\n}\n"
    },
    "contracts/interface/IGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IGauge {\n    function notifyRewardAmount(address token, uint amount) external;\n\n    function getReward(address account, address[] memory tokens) external;\n\n    function claimFees() external returns (uint claimed0, uint claimed1);\n}\n"
    },
    "contracts/interface/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interface/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/interface/IVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IVoter {\n    function ve() external view returns (address);\n\n    function attachTokenToGauge(uint _tokenId, address account) external;\n\n    function detachTokenFromGauge(uint _tokenId, address account) external;\n\n    function emitDeposit(\n        uint _tokenId,\n        address account,\n        uint amount\n    ) external;\n\n    function emitWithdraw(\n        uint _tokenId,\n        address account,\n        uint amount\n    ) external;\n\n    function distribute(address _gauge) external;\n\n    function notifyRewardAmount(uint amount) external;\n\n    function init(address[] memory _tokens, address _minter) external;\n}\n"
    },
    "contracts/interface/IVe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IVe {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME,\n        MERGE_TYPE\n    }\n\n    struct Point {\n        int128 bias;\n        int128 slope; // # -dweight / dt\n        uint ts;\n        uint blk; // block\n    }\n    /* We cannot really do block numbers per se b/c slope is per time, not per block\n     * and per block could be fairly bad b/c Ethereum changes blocktimes.\n     * What we can do is to extrapolate ***At functions */\n\n    struct LockedBalance {\n        int128 amount;\n        uint end;\n    }\n\n    function token() external view returns (address);\n\n    function balanceOfNFT(uint) external view returns (uint);\n\n    function isApprovedOrOwner(address, uint) external view returns (bool);\n\n    function createLockFor(\n        uint,\n        uint,\n        address\n    ) external returns (uint);\n\n    function userPointEpoch(uint tokenId) external view returns (uint);\n\n    function epoch() external view returns (uint);\n\n    function userPointHistory(uint tokenId, uint loc)\n        external\n        view\n        returns (Point memory);\n\n    function pointHistory(uint loc) external view returns (Point memory);\n\n    function checkpoint() external;\n\n    function depositFor(uint tokenId, uint value) external;\n\n    function attachToken(uint tokenId) external;\n\n    function detachToken(uint tokenId) external;\n\n    function voting(uint tokenId) external;\n\n    function abstain(uint tokenId) external;\n}\n"
    },
    "contracts/lib/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.13;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n}\n"
    },
    "contracts/interface/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  }
}
