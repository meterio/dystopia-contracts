{
    "language": "Solidity",
    "sources": {
        "contracts/base/periphery/VoltRouter01.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../lib/Math.sol\";\nimport \"../../lib/SafeERC20.sol\";\nimport \"../../interface/IERC20.sol\";\nimport \"../../interface/IWETH.sol\";\nimport \"../../interface/IPair.sol\";\nimport \"../../interface/IFactory.sol\";\n\ncontract VoltRouter01 {\n    using SafeERC20 for IERC20;\n\n    struct Route {\n        address from;\n        address to;\n        bool stable;\n    }\n\n    address public immutable factory;\n    IWETH public immutable wmtr;\n    uint internal constant MINIMUM_LIQUIDITY = 10**3;\n    bytes32 immutable pairCodeHash;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, \"VoltRouter: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _wmtr) {\n        factory = _factory;\n        pairCodeHash = IFactory(_factory).pairCodeHash();\n        wmtr = IWETH(_wmtr);\n    }\n\n    receive() external payable {\n        // only accept ETH via fallback from the WETH contract\n        require(msg.sender == address(wmtr), \"VoltRouter: NOT_WETH\");\n    }\n\n    function sortTokens(address tokenA, address tokenB)\n        external\n        pure\n        returns (address token0, address token1)\n    {\n        return _sortTokens(tokenA, tokenB);\n    }\n\n    function _sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"VoltRouter: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"VoltRouter: ZERO_ADDRESS\");\n    }\n\n    function pairFor(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external view returns (address pair) {\n        return _pairFor(tokenA, tokenB, stable);\n    }\n\n    /// @dev Calculates the CREATE2 address for a pair without making any external calls.\n    function _pairFor(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) internal view returns (address pair) {\n        (address token0, address token1) = _sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(abi.encodePacked(token0, token1, stable)),\n                            pairCodeHash // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function quoteLiquidity(\n        uint amountA,\n        uint reserveA,\n        uint reserveB\n    ) external pure returns (uint amountB) {\n        return _quoteLiquidity(amountA, reserveA, reserveB);\n    }\n\n    /// @dev Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset.\n    function _quoteLiquidity(\n        uint amountA,\n        uint reserveA,\n        uint reserveB\n    ) internal pure returns (uint amountB) {\n        require(amountA > 0, \"VoltRouter: INSUFFICIENT_AMOUNT\");\n        require(\n            reserveA > 0 && reserveB > 0,\n            \"VoltRouter: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = (amountA * reserveB) / reserveA;\n    }\n\n    function getReserves(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external view returns (uint reserveA, uint reserveB) {\n        return _getReserves(tokenA, tokenB, stable);\n    }\n\n    /// @dev Fetches and sorts the reserves for a pair.\n    function _getReserves(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) internal view returns (uint reserveA, uint reserveB) {\n        (address token0, ) = _sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1, ) = IPair(\n            _pairFor(tokenA, tokenB, stable)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    /// @dev Performs chained getAmountOut calculations on any number of pairs.\n    function getAmountOut(\n        uint amountIn,\n        address tokenIn,\n        address tokenOut\n    ) external view returns (uint amount, bool stable) {\n        address pair = _pairFor(tokenIn, tokenOut, true);\n        uint amountStable;\n        uint amountVolatile;\n        if (IFactory(factory).isPair(pair)) {\n            amountStable = IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        pair = _pairFor(tokenIn, tokenOut, false);\n        if (IFactory(factory).isPair(pair)) {\n            amountVolatile = IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        return\n            amountStable > amountVolatile\n                ? (amountStable, true)\n                : (amountVolatile, false);\n    }\n\n    function getExactAmountOut(\n        uint amountIn,\n        address tokenIn,\n        address tokenOut,\n        bool stable\n    ) external view returns (uint) {\n        address pair = _pairFor(tokenIn, tokenOut, stable);\n        if (IFactory(factory).isPair(pair)) {\n            return IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        return 0;\n    }\n\n    /// @dev Performs chained getAmountOut calculations on any number of pairs.\n    function getAmountsOut(uint amountIn, Route[] memory routes)\n        external\n        view\n        returns (uint[] memory amounts)\n    {\n        return _getAmountsOut(amountIn, routes);\n    }\n\n    function _getAmountsOut(uint amountIn, Route[] memory routes)\n        internal\n        view\n        returns (uint[] memory amounts)\n    {\n        require(routes.length >= 1, \"VoltRouter: INVALID_PATH\");\n        amounts = new uint[](routes.length + 1);\n        amounts[0] = amountIn;\n        for (uint i = 0; i < routes.length; i++) {\n            address pair = _pairFor(\n                routes[i].from,\n                routes[i].to,\n                routes[i].stable\n            );\n            if (IFactory(factory).isPair(pair)) {\n                amounts[i + 1] = IPair(pair).getAmountOut(\n                    amounts[i],\n                    routes[i].from\n                );\n            }\n        }\n    }\n\n    function isPair(address pair) external view returns (bool) {\n        return IFactory(factory).isPair(pair);\n    }\n\n    function quoteAddLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired\n    )\n        external\n        view\n        returns (\n            uint amountA,\n            uint amountB,\n            uint liquidity\n        )\n    {\n        // create the pair if it doesn't exist yet\n        address _pair = IFactory(factory).getPair(tokenA, tokenB, stable);\n        (uint reserveA, uint reserveB) = (0, 0);\n        uint _totalSupply = 0;\n        if (_pair != address(0)) {\n            _totalSupply = IERC20(_pair).totalSupply();\n            (reserveA, reserveB) = _getReserves(tokenA, tokenB, stable);\n        }\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n            liquidity = Math.sqrt(amountA * amountB) - MINIMUM_LIQUIDITY;\n        } else {\n            uint amountBOptimal = _quoteLiquidity(\n                amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= amountBDesired) {\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n                liquidity = Math.min(\n                    (amountA * _totalSupply) / reserveA,\n                    (amountB * _totalSupply) / reserveB\n                );\n            } else {\n                uint amountAOptimal = _quoteLiquidity(\n                    amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n                liquidity = Math.min(\n                    (amountA * _totalSupply) / reserveA,\n                    (amountB * _totalSupply) / reserveB\n                );\n            }\n        }\n    }\n\n    function quoteRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity\n    ) external view returns (uint amountA, uint amountB) {\n        // create the pair if it doesn't exist yet\n        address _pair = IFactory(factory).getPair(tokenA, tokenB, stable);\n\n        if (_pair == address(0)) {\n            return (0, 0);\n        }\n\n        (uint reserveA, uint reserveB) = _getReserves(tokenA, tokenB, stable);\n        uint _totalSupply = IERC20(_pair).totalSupply();\n        // using balances ensures pro-rata distribution\n        amountA = (liquidity * reserveA) / _totalSupply;\n        // using balances ensures pro-rata distribution\n        amountB = (liquidity * reserveB) / _totalSupply;\n    }\n\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal returns (uint amountA, uint amountB) {\n        require(amountADesired >= amountAMin, \"VoltRouter: DESIRED_A_AMOUNT\");\n        require(amountBDesired >= amountBMin, \"VoltRouter: DESIRED_B_AMOUNT\");\n        // create the pair if it doesn't exist yet\n        address _pair = IFactory(factory).getPair(tokenA, tokenB, stable);\n        if (_pair == address(0)) {\n            _pair = IFactory(factory).createPair(tokenA, tokenB, stable);\n        }\n        (uint reserveA, uint reserveB) = _getReserves(tokenA, tokenB, stable);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = _quoteLiquidity(\n                amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= amountBDesired) {\n                require(\n                    amountBOptimal >= amountBMin,\n                    \"VoltRouter: INSUFFICIENT_B_AMOUNT\"\n                );\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = _quoteLiquidity(\n                    amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                assert(amountAOptimal <= amountADesired);\n                require(\n                    amountAOptimal >= amountAMin,\n                    \"VoltRouter: INSUFFICIENT_A_AMOUNT\"\n                );\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    )\n        external\n        ensure(deadline)\n        returns (\n            uint amountA,\n            uint amountB,\n            uint liquidity\n        )\n    {\n        (amountA, amountB) = _addLiquidity(\n            tokenA,\n            tokenB,\n            stable,\n            amountADesired,\n            amountBDesired,\n            amountAMin,\n            amountBMin\n        );\n        address pair = _pairFor(tokenA, tokenB, stable);\n        SafeERC20.safeTransferFrom(IERC20(tokenA), msg.sender, pair, amountA);\n        SafeERC20.safeTransferFrom(IERC20(tokenB), msg.sender, pair, amountB);\n        liquidity = IPair(pair).mint(to);\n    }\n\n    function addLiquidityMTR(\n        address token,\n        bool stable,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountMTRMin,\n        address to,\n        uint deadline\n    )\n        external\n        payable\n        ensure(deadline)\n        returns (\n            uint amountToken,\n            uint amountMTR,\n            uint liquidity\n        )\n    {\n        (amountToken, amountMTR) = _addLiquidity(\n            token,\n            address(wmtr),\n            stable,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountMTRMin\n        );\n        address pair = _pairFor(token, address(wmtr), stable);\n        IERC20(token).safeTransferFrom(msg.sender, pair, amountToken);\n        wmtr.deposit{value: amountMTR}();\n        assert(wmtr.transfer(pair, amountMTR));\n        liquidity = IPair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountMTR)\n            _safeTransferMTR(msg.sender, msg.value - amountMTR);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB) {\n        return\n            _removeLiquidity(\n                tokenA,\n                tokenB,\n                stable,\n                liquidity,\n                amountAMin,\n                amountBMin,\n                to,\n                deadline\n            );\n    }\n\n    function _removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) internal ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = _pairFor(tokenA, tokenB, stable);\n        IERC20(pair).safeTransferFrom(msg.sender, pair, liquidity);\n        // send liquidity to pair\n        (uint amount0, uint amount1) = IPair(pair).burn(to);\n        (address token0, ) = _sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0\n            ? (amount0, amount1)\n            : (amount1, amount0);\n        require(amountA >= amountAMin, \"VoltRouter: INSUFFICIENT_A_AMOUNT\");\n        require(amountB >= amountBMin, \"VoltRouter: INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function removeLiquidityMTR(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountMTRMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountMTR) {\n        return\n            _removeLiquidityMTR(\n                token,\n                stable,\n                liquidity,\n                amountTokenMin,\n                amountMTRMin,\n                to,\n                deadline\n            );\n    }\n\n    function _removeLiquidityMTR(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountMTRMin,\n        address to,\n        uint deadline\n    ) internal ensure(deadline) returns (uint amountToken, uint amountMTR) {\n        (amountToken, amountMTR) = _removeLiquidity(\n            token,\n            address(wmtr),\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountMTRMin,\n            address(this),\n            deadline\n        );\n        IERC20(token).safeTransfer(to, amountToken);\n        wmtr.withdraw(amountMTR);\n        _safeTransferMTR(to, amountMTR);\n    }\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountA, uint amountB) {\n        address pair = _pairFor(tokenA, tokenB, stable);\n        {\n            uint value = approveMax ? type(uint).max : liquidity;\n            IPair(pair).permit(\n                msg.sender,\n                address(this),\n                value,\n                deadline,\n                v,\n                r,\n                s\n            );\n        }\n\n        (amountA, amountB) = _removeLiquidity(\n            tokenA,\n            tokenB,\n            stable,\n            liquidity,\n            amountAMin,\n            amountBMin,\n            to,\n            deadline\n        );\n    }\n\n    function removeLiquidityMTRWithPermit(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountMTRMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountToken, uint amountMTR) {\n        address pair = _pairFor(token, address(wmtr), stable);\n        uint value = approveMax ? type(uint).max : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountMTR) = _removeLiquidityMTR(\n            token,\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountMTRMin,\n            to,\n            deadline\n        );\n    }\n\n    function removeLiquidityMTRSupportingFeeOnTransferTokens(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountFTMMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountFTM) {\n        return\n            _removeLiquidityMTRSupportingFeeOnTransferTokens(\n                token,\n                stable,\n                liquidity,\n                amountTokenMin,\n                amountFTMMin,\n                to,\n                deadline\n            );\n    }\n\n    function _removeLiquidityMTRSupportingFeeOnTransferTokens(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountFTMMin,\n        address to,\n        uint deadline\n    ) internal ensure(deadline) returns (uint amountToken, uint amountFTM) {\n        (amountToken, amountFTM) = _removeLiquidity(\n            token,\n            address(wmtr),\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountFTMMin,\n            address(this),\n            deadline\n        );\n        IERC20(token).safeTransfer(to, IERC20(token).balanceOf(address(this)));\n        wmtr.withdraw(amountFTM);\n        _safeTransferMTR(to, amountFTM);\n    }\n\n    function removeLiquidityMTRWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountFTMMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountToken, uint amountFTM) {\n        address pair = _pairFor(token, address(wmtr), stable);\n        uint value = approveMax ? type(uint).max : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (\n            amountToken,\n            amountFTM\n        ) = _removeLiquidityMTRSupportingFeeOnTransferTokens(\n            token,\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountFTMMin,\n            to,\n            deadline\n        );\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        uint[] memory amounts,\n        Route[] memory routes,\n        address _to\n    ) internal virtual {\n        for (uint i = 0; i < routes.length; i++) {\n            (address token0, ) = _sortTokens(routes[i].from, routes[i].to);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = routes[i].from == token0\n                ? (uint(0), amountOut)\n                : (amountOut, uint(0));\n            address to = i < routes.length - 1\n                ? _pairFor(\n                    routes[i + 1].from,\n                    routes[i + 1].to,\n                    routes[i + 1].stable\n                )\n                : _to;\n            IPair(_pairFor(routes[i].from, routes[i].to, routes[i].stable))\n                .swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    function _swapSupportingFeeOnTransferTokens(\n        Route[] memory routes,\n        address _to\n    ) internal virtual {\n        for (uint i; i < routes.length; i++) {\n            (address input, address output) = (routes[i].from, routes[i].to);\n            (address token0, ) = _sortTokens(input, output);\n            IPair pair = IPair(\n                _pairFor(routes[i].from, routes[i].to, routes[i].stable)\n            );\n            uint amountInput;\n            uint amountOutput;\n            {\n                // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1, ) = pair.getReserves();\n                uint reserveInput = input == token0 ? reserve0 : reserve1;\n                amountInput =\n                    IERC20(input).balanceOf(address(pair)) -\n                    reserveInput;\n                //(amountOutput,) = getAmountOut(amountInput, input, output, stable);\n                amountOutput = pair.getAmountOut(amountInput, input);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0\n                ? (uint(0), amountOutput)\n                : (amountOutput, uint(0));\n            address to = i < routes.length - 1\n                ? _pairFor(\n                    routes[i + 1].from,\n                    routes[i + 1].to,\n                    routes[i + 1].stable\n                )\n                : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    function swapExactTokensForTokensSimple(\n        uint amountIn,\n        uint amountOutMin,\n        address tokenFrom,\n        address tokenTo,\n        bool stable,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        Route[] memory routes = new Route[](1);\n        routes[0].from = tokenFrom;\n        routes[0].to = tokenTo;\n        routes[0].stable = stable;\n        amounts = _getAmountsOut(amountIn, routes);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"VoltRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        amounts = _getAmountsOut(amountIn, routes);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"VoltRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactMTRForTokens(\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external payable ensure(deadline) returns (uint[] memory amounts) {\n        require(routes[0].from == address(wmtr), \"VoltRouter: INVALID_PATH\");\n        amounts = _getAmountsOut(msg.value, routes);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"VoltRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        wmtr.deposit{value: amounts[0]}();\n        assert(\n            wmtr.transfer(\n                _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n                amounts[0]\n            )\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactTokensForMTR(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        require(\n            routes[routes.length - 1].to == address(wmtr),\n            \"VoltRouter: INVALID_PATH\"\n        );\n        amounts = _getAmountsOut(amountIn, routes);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"VoltRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amounts[0]\n        );\n        _swap(amounts, routes, address(this));\n        wmtr.withdraw(amounts[amounts.length - 1]);\n        _safeTransferMTR(to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) {\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amountIn\n        );\n        uint balanceBefore = IERC20(routes[routes.length - 1].to).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(routes, to);\n        require(\n            IERC20(routes[routes.length - 1].to).balanceOf(to) -\n                balanceBefore >=\n                amountOutMin,\n            \"VoltRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n    }\n\n    function swapExactMTRForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external payable ensure(deadline) {\n        require(routes[0].from == address(wmtr), \"VoltRouter: INVALID_PATH\");\n        uint amountIn = msg.value;\n        wmtr.deposit{value: amountIn}();\n        assert(\n            wmtr.transfer(\n                _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n                amountIn\n            )\n        );\n        uint balanceBefore = IERC20(routes[routes.length - 1].to).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(routes, to);\n        require(\n            IERC20(routes[routes.length - 1].to).balanceOf(to) -\n                balanceBefore >=\n                amountOutMin,\n            \"VoltRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n    }\n\n    function swapExactTokensForMTRSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) {\n        require(\n            routes[routes.length - 1].to == address(wmtr),\n            \"VoltRouter: INVALID_PATH\"\n        );\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(routes, address(this));\n        uint amountOut = IERC20(address(wmtr)).balanceOf(address(this));\n        require(\n            amountOut >= amountOutMin,\n            \"VoltRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        wmtr.withdraw(amountOut);\n        _safeTransferMTR(to, amountOut);\n    }\n\n    function UNSAFE_swapExactTokensForTokens(\n        uint[] memory amounts,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory) {\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amounts[0]\n        );\n        _swap(amounts, routes, to);\n        return amounts;\n    }\n\n    function _safeTransferMTR(address to, uint value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"VoltRouter: ETH_TRANSFER_FAILED\");\n    }\n}\n"
        },
        "contracts/interface/IFactory.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IFactory {\n    function treasury() external view returns (address);\n\n    function isPair(address pair) external view returns (bool);\n\n    function getInitializable()\n        external\n        view\n        returns (\n            address,\n            address,\n            bool\n        );\n\n    function isPaused() external view returns (bool);\n\n    function pairCodeHash() external pure returns (bytes32);\n\n    function getPair(\n        address tokenA,\n        address token,\n        bool stable\n    ) external view returns (address);\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external returns (address pair);\n}\n"
        },
        "contracts/interface/IPair.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IPair {\n    // Structure to capture time period obervations every 30 minutes, used for local oracles\n    struct Observation {\n        uint timestamp;\n        uint reserve0Cumulative;\n        uint reserve1Cumulative;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function burn(address to) external returns (uint amount0, uint amount1);\n\n    function mint(address to) external returns (uint liquidity);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        );\n\n    function getAmountOut(uint, address) external view returns (uint);\n\n    function claimFees() external returns (uint, uint);\n\n    function tokens() external view returns (address, address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function stable() external view returns (bool);\n\n    function metadata()\n        external\n        view\n        returns (\n            uint dec0,\n            uint dec1,\n            uint r0,\n            uint r1,\n            bool st,\n            address t0,\n            address t1\n        );\n}\n"
        },
        "contracts/interface/IWETH.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IWETH {\n    function name() external view returns (string memory);\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function symbol() external view returns (string memory);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function deposit() external payable;\n\n    function allowance(address, address) external view returns (uint256);\n}\n"
        },
        "contracts/interface/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
        },
        "contracts/lib/SafeERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.13;\n\nimport \"../interface/IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint value\n    ) internal {\n        uint newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n"
        },
        "contracts/lib/Math.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nlibrary Math {\n    function max(uint a, uint b) internal pure returns (uint) {\n        return a >= b ? a : b;\n    }\n\n    function min(uint a, uint b) internal pure returns (uint) {\n        return a < b ? a : b;\n    }\n\n    function positiveInt128(int128 value) internal pure returns (int128) {\n        return value < 0 ? int128(0) : value;\n    }\n\n    function closeTo(\n        uint a,\n        uint b,\n        uint target\n    ) internal pure returns (bool) {\n        if (a > b) {\n            if (a - b <= target) {\n                return true;\n            }\n        } else {\n            if (b - a <= target) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
        },
        "contracts/lib/Address.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.13;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n}\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "": [
                    "ast"
                ],
                "*": [
                    "abi",
                    "metadata",
                    "devdoc",
                    "userdoc",
                    "storageLayout",
                    "evm.legacyAssembly",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "evm.gasEstimates",
                    "evm.assembly"
                ]
            }
        }
    }
}