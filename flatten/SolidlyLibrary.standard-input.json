{
  "language": "Solidity",
  "sources": {
    "contracts/lib/SolidlyLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\nimport \"../interface/IPair.sol\";\nimport \"../interface/IRouter.sol\";\n\ncontract SolidlyLibrary {\n    IRouter internal router;\n\n    constructor(address _router) {\n        router = IRouter(_router);\n    }\n\n    function _f(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return\n            (x0 * ((((y * y) / 1e18) * y) / 1e18)) /\n            1e18 +\n            (((((x0 * x0) / 1e18) * x0) / 1e18) * y) /\n            1e18;\n    }\n\n    function _d(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return\n            (3 * x0 * ((y * y) / 1e18)) /\n            1e18 +\n            ((((x0 * x0) / 1e18) * x0) / 1e18);\n    }\n\n    function _get_y(\n        uint256 x0,\n        uint256 xy,\n        uint256 y\n    ) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 255; i++) {\n            uint256 y_prev = y;\n            uint256 k = _f(x0, y);\n            if (k < xy) {\n                uint256 dy = ((xy - k) * 1e18) / _d(x0, y);\n                y = y + dy;\n            } else {\n                uint256 dy = ((k - xy) * 1e18) / _d(x0, y);\n                y = y - dy;\n            }\n            if (y > y_prev) {\n                if (y - y_prev <= 1) {\n                    return y;\n                }\n            } else {\n                if (y_prev - y <= 1) {\n                    return y;\n                }\n            }\n        }\n        return y;\n    }\n\n    function getTradeDiff(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut,\n        bool stable\n    ) external view returns (uint256 a, uint256 b) {\n        (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            bool st,\n            address t0,\n\n        ) = IPair(router.pairFor(tokenIn, tokenOut, stable)).metadata();\n        uint256 sample = tokenIn == t0 ? (r0 * dec1) / r1 : (r1 * dec0) / r0;\n        a =\n            (_getAmountOut(sample, tokenIn, r0, r1, t0, dec0, dec1, st) *\n                1e18) /\n            sample;\n        b =\n            (_getAmountOut(amountIn, tokenIn, r0, r1, t0, dec0, dec1, st) *\n                1e18) /\n            amountIn;\n    }\n\n    function getTradeDiff(\n        uint256 amountIn,\n        address tokenIn,\n        address pair\n    ) external view returns (uint256 a, uint256 b) {\n        (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            bool st,\n            address t0,\n\n        ) = IPair(pair).metadata();\n        uint256 sample = tokenIn == t0 ? (r0 * dec1) / r1 : (r1 * dec0) / r0;\n        a =\n            (_getAmountOut(sample, tokenIn, r0, r1, t0, dec0, dec1, st) *\n                1e18) /\n            sample;\n        b =\n            (_getAmountOut(amountIn, tokenIn, r0, r1, t0, dec0, dec1, st) *\n                1e18) /\n            amountIn;\n    }\n\n    function getSample(\n        address tokenIn,\n        address tokenOut,\n        bool stable\n    ) external view returns (uint256) {\n        (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            bool st,\n            address t0,\n\n        ) = IPair(router.pairFor(tokenIn, tokenOut, stable)).metadata();\n        uint256 sample = tokenIn == t0 ? (r0 * dec1) / r1 : (r1 * dec0) / r0;\n        return\n            (_getAmountOut(sample, tokenIn, r0, r1, t0, dec0, dec1, st) *\n                1e18) / sample;\n    }\n\n    function getMinimumValue(\n        address tokenIn,\n        address tokenOut,\n        bool stable\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            ,\n            address t0,\n\n        ) = IPair(router.pairFor(tokenIn, tokenOut, stable)).metadata();\n        uint256 sample = tokenIn == t0 ? (r0 * dec1) / r1 : (r1 * dec0) / r0;\n        return (sample, r0, r1);\n    }\n\n    function getAmountOut(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut,\n        bool stable\n    ) external view returns (uint256) {\n        (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            bool st,\n            address t0,\n\n        ) = IPair(router.pairFor(tokenIn, tokenOut, stable)).metadata();\n        return\n            (_getAmountOut(amountIn, tokenIn, r0, r1, t0, dec0, dec1, st) *\n                1e18) / amountIn;\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        address tokenIn,\n        uint256 _reserve0,\n        uint256 _reserve1,\n        address token0,\n        uint256 decimals0,\n        uint256 decimals1,\n        bool stable\n    ) internal pure returns (uint256) {\n        if (stable) {\n            uint256 xy = _k(_reserve0, _reserve1, stable, decimals0, decimals1);\n            _reserve0 = (_reserve0 * 1e18) / decimals0;\n            _reserve1 = (_reserve1 * 1e18) / decimals1;\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0\n                ? (_reserve0, _reserve1)\n                : (_reserve1, _reserve0);\n            amountIn = tokenIn == token0\n                ? (amountIn * 1e18) / decimals0\n                : (amountIn * 1e18) / decimals1;\n            uint256 y = reserveB - _get_y(amountIn + reserveA, xy, reserveB);\n            return (y * (tokenIn == token0 ? decimals1 : decimals0)) / 1e18;\n        } else {\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0\n                ? (_reserve0, _reserve1)\n                : (_reserve1, _reserve0);\n            return (amountIn * reserveB) / (reserveA + amountIn);\n        }\n    }\n\n    function _k(\n        uint256 x,\n        uint256 y,\n        bool stable,\n        uint256 decimals0,\n        uint256 decimals1\n    ) internal pure returns (uint256) {\n        if (stable) {\n            uint256 _x = (x * 1e18) / decimals0;\n            uint256 _y = (y * 1e18) / decimals1;\n            uint256 _a = (_x * _y) / 1e18;\n            uint256 _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\n            return (_a * _b) / 1e18; // x3y+y3x >= k\n        } else {\n            return x * y; // xy >= k\n        }\n    }\n}\n"
    },
    "contracts/interface/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IRouter {\n    struct Route {\n        address from;\n        address to;\n        bool stable;\n    }\n\n    function factory() external view returns (address);\n\n    function WMTR() external view returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    )\n        external\n        returns (\n            uint amountA,\n            uint amountB,\n            uint liquidity\n        );\n\n    function addLiquidityMTR(\n        address token,\n        bool stable,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountMTRMin,\n        address to,\n        uint deadline\n    )\n        external\n        payable\n        returns (\n            uint amountToken,\n            uint amountMTR,\n            uint liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityMTR(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountMTRMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountMTR);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityMTRWithPermit(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountMTRMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountToken, uint amountMTR);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactMTRForTokens(\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function swapTokensForExactMTR(\n        uint amountOut,\n        uint amountInMax,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactTokensForMTR(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapMTRForExactTokens(\n        uint amountOut,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function quoteRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity\n    ) external view returns (uint amountA, uint amountB);\n\n    function quoteAddLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired\n    )\n        external\n        view\n        returns (\n            uint amountA,\n            uint amountB,\n            uint liquidity\n        );\n\n    function pairFor(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external view returns (address pair);\n\n    function sortTokens(address tokenA, address tokenB)\n        external\n        pure\n        returns (address token0, address token1);\n\n    function quoteLiquidity(\n        uint amountA,\n        uint reserveA,\n        uint reserveB\n    ) external pure returns (uint amountB);\n\n    function getAmountOut(\n        uint amountIn,\n        address tokenIn,\n        address tokenOut\n    ) external view returns (uint amount, bool stable);\n\n    function getAmountIn(\n        uint amountOut,\n        uint reserveIn,\n        uint reserveOut\n    ) external pure returns (uint amountIn, bool stable);\n\n    function getAmountsOut(uint amountIn, Route[] memory routes)\n        external\n        view\n        returns (uint[] memory amounts);\n\n    function getAmountsIn(uint amountOut, Route[] memory routes)\n        external\n        view\n        returns (uint[] memory amounts);\n\n    function getReserves(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external view returns (uint reserveA, uint reserveB);\n\n    function getExactAmountOut(\n        uint amountIn,\n        address tokenIn,\n        address tokenOut,\n        bool stable\n    ) external view returns (uint amount);\n\n    function isPair(address pair) external view returns (bool);\n\n    function swapExactTokensForTokensSimple(\n        uint amountIn,\n        uint amountOutMin,\n        address tokenFrom,\n        address tokenTo,\n        bool stable,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactTokensForMTRSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactMTRForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external;\n\n    function removeLiquidityMTRWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountFTMMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountToken, uint amountFTM);\n\n    function removeLiquidityMTRSupportingFeeOnTransferTokens(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountFTMMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountFTM);\n}\n"
    },
    "contracts/interface/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IPair {\n    // Structure to capture time period obervations every 30 minutes, used for local oracles\n    struct Observation {\n        uint timestamp;\n        uint reserve0Cumulative;\n        uint reserve1Cumulative;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function burn(address to) external returns (uint amount0, uint amount1);\n\n    function mint(address to) external returns (uint liquidity);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        );\n\n    function getAmountOut(uint, address) external view returns (uint);\n\n    function claimFees() external returns (uint, uint);\n\n    function tokens() external view returns (address, address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function stable() external view returns (bool);\n\n    function metadata()\n        external\n        view\n        returns (\n            uint dec0,\n            uint dec1,\n            uint r0,\n            uint r1,\n            bool st,\n            address t0,\n            address t1\n        );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "": ["ast"],
        "*": [
          "abi",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.legacyAssembly",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "evm.gasEstimates",
          "evm.assembly"
        ]
      }
    },
    "evmVersion": "london"
  }
}
